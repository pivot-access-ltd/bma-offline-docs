<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="css/stylesheet.css" />
    <style>
      #selector a:link{color:black;}
      #selector a:visited{color:black;}
      #selector a:active{color:black;}
      #selector a:hover{color:blue;}
      #sidebar a:link{color:black;}
      #sidebar a:visited{color:black;}
      #sidebar a:active{color:black;}
      #sidebar a:hover{color:blue;}
      ul {margin-left:0;list-style-type:none;}
      li {margin: 4px 0;}
    </style>
  </head>
  <body>
    <div id="selector" style="top:0; position:fixed; float:right; background-color:#d9d9d9; width:100%;border-bottom:1px solid black;">
      &nbsp;&nbsp;<strong>Offline docs</strong>
      <a href="https://maas.io/docs">(switch to live docs)</a>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<a href="../ui/maas-glossary.html">
	  UI-only
	</a>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      <span style="background-color:white;border-top:1px solid black; border-left:1px solid black; border-right:1px solid black; border-bottom:5px solid white;">
	  &nbsp;CLI-only&nbsp;
      </span>
    </div>
    <div id="sidebar" style="float:left; width:25%;margin-top:40px; margin-left:20px">
      <strong>
	<a href="maas-documentation-25.html">
	  Home
	</a>
      </strong>
      <ul>
	<li>
	  <a href="what-is-new-with-maas.html">
	    Release notes
	  </a>
	</li>
	<li>
	  <a href="maas-installation-requirements.html">
	    Installation requirements
	  </a>
	</li>
	<li>
	  <a href="maas-glossary.html">
	    Glossary
	  </a>
	</li>
      </ul>
      <strong>
	<a href="basic-tutorials.html">
	  Basic tutorials
	</a>
      </strong>
      <ul>
	<li>
	  <a href="maas-bootstrap-tutorial.html">
	    MAAS bootstrap tutorial
	  </a>
	</li>
	<li>
	  <a href="try-out-the-maas-cli.html">
	    Try out the MAAS CLI
	  </a>
	</li>
	<li>
	  <a href="custom-image-tutorial.html">
	    Custom image tutorial
	  </a>
	</li>
	<li>
	  <a href="using-jq-with-the-maas-cli.html">
	    Using jq with the MAAS CLI
	  </a>
	</li>
      </ul>
      <strong>
	<a href="how-to-get-started-with-maas.html">
	  How to get started with MAAS
	</a>
      </strong>
      <ul>
	<li>
	  <a href="how-to-spin-up-maas-with-ansible.html">
	    Spin up MAAS with Ansible
	  </a>
	</li>
	<li>
	  <a href="how-to-install-maas.html">
	    Install MAAS
	  </a>
	</li>
	<li>
	  <a href="how-to-upgrade-maas.html">
	    Upgrade MAAS
	  </a>
	</li>
	<li>
	  <a href="how-to-change-maas-settings.html">
	    Change MAAS settings
	  </a>
	</li>
	<li>
	  <a href="how-to-get-help.html">
	    Ask for help
	  </a>
	</li>
	<li>
	  <a href="how-to-request-a-feature.html">
	    Request a feature
	  </a>
	</li>
	<li>
	  <a href="how-to-report-a-bug.html">
	    Report a bug
	  </a>
	</li>
      </ul>
      <strong>
	<a href="how-to-set-up-networks.html">
	  How to set up networks
	</a>
      </strong>
      <ul>
	<li>
	  <a href="how-to-connect-maas-networks.html">
	    Connect MAAS networks
	  </a>
	</li>
	<li>
	  <a href="how-to-enable-dhcp.html">
	    Enable DHCP
	  </a>
	</li>
	<li>
	  <a href="how-to-manage-availability-zones.html">
	    Manage zones (AZs)
	  </a>
	</li>
      </ul>
      <strong>
	<a href="how-to-acquire-images.html">
	  How to acquire images
	</a>
      </strong>
      <ul>
	<li>
	  <a href="how-to-use-standard-images.html">
	    Use standard images
	  </a>
	</li>
	<li>
	  <a href="how-to-mirror-images-locally.html">
	    Mirror images locally
	  </a>
	</li>
	<li>
	  <a href="how-to-build-custom-images.html">
	    Build custom images
	  </a>
	</li>
	<li>
	  <a href="how-to-employ-vmware-images.html">
	    Employ VMWare images
	  </a>
	</li>
      </ul>
      <strong>
	<a href="how-to-tune-controllers.html">
	  How to tune controllers
	</a>
      </strong>
      <ul>
	<li>
	  <a href="how-to-adjust-your-controllers.html">
	    Adjust your controllers
	  </a>
	</li>
	<li>
	  <a href="how-to-enable-high-availability.html">
	    Enable HA
	  </a>
	</li>
      </ul>
      <strong>
	<a href="how-to-deploy-physical-machines.html">
	  How to deploy physical machines
	</a>
      </strong>
      <ul>
	<li>
	  <a href="how-to-make-machines-available.html">
	    Make machines available
	  </a>
	</li>
	<li>
	  <a href="how-to-customise-machines.html">
	    Customise machines
	  </a>
	</li>
	<li>
	  <a href="how-to-put-machines-to-work.html">
	    Put machines to work
	  </a>
	</li>
      </ul>
      <strong>
	<a href="how-to-deploy-virtual-machines.html">
	  How to deploy virtual machines
	</a>
      </strong>
      <ul>
	<li>
	  <a href="how-to-set-up-lxd.html">
	    Set up LXD
	  </a>
	</li>
	<li>
	  <a href="how-to-create-vm-hosts.html">
	    Create VM hosts
	  </a>
	</li>
	<li>
	  <a href="how-to-create-and-manage-vms.html">
	    Create and manage VMs
	  </a>
	</li>
      </ul>
      <strong>
	<a href="how-to-label-and-find-machines.html">
	  How to label and find machines
	</a>
      </strong>
      <ul>
	<li>
	  <a href="how-to-tag-machines.html">
	    Tag machines
	  </a>
	</li>
	<li>
	  <a href="how-to-annotate-machines.html">
	    Annotate machines
	  </a>
	</li>
	<li>
	  <a href="how-to-use-machine-tags.html">
	    Use machine tags
	  </a>
	</li>
	<li>
	  <a href="how-to-use-controller-tags.html">
	    Use controller tags
	  </a>
	</li>
	<li>
	  <a href="how-to-use-storage-tags.html">
	    Use storage tags
	  </a>
	</li>
	<li>
	  <a href="how-to-use-network-tags.html">
	    Use network tags
	  </a>
	</li>
	<li>
	  <a href="how-to-find-machines.html">
	    Find machines
	  </a>
	</li>
      </ul>
      <strong>
	How to diagnose issues
      </strong>
      <ul>
	<li>
	  <a href="how-to-work-with-log-files.html">
	    Work with log files
	  </a>
	</li>
	<li>
	  <a href="how-to-work-with-audit-event-logs.html">
	    Work with audit event logs
	  </a>
	</li>
	<li>
	  <a href="how-to-troubleshoot-maas.html">
	    Troubleshoot MAAS
	  </a>
	</li>
      </ul>
      <strong>
	How to work securely
      </strong>
      <ul>
	<li>
	  <a href="how-to-improve-maas-security.html">
	    Improve MAAS security
	  </a>
	</li>
	<li>
	  <a href="how-to-enable-maas-native-tls.html">
	    Enable MAAS native TLS
	  </a>
	</li>
	<li>
	  <a href="how-to-set-up-an-air-gapped-maas.html">
	    Set up an air-gapped MAAS
	  </a>
	</li>
	<li>
	  <a href="how-to-manage-user-accounts.html">
	    Manage user accounts
	  </a>
	</li>
      </ul>
      <strong>
	How to operate reliably
      </strong>
      <ul>
	<li>
	  <a href="how-to-keep-maas-backed-up.html">
	    Keep MAAS backed up
	  </a>
	</li>
	<li>
	  <a href="how-to-observe-a-live-maas.html">
	    Observe a live MAAS
	  </a>
	</li>
      </ul>
      <strong>
	<a href="how-to-protect-your-secrets.html">
	How to protect your secrets
	</a>
      </strong>
      <ul>
	<li>
	  <a href="how-to-enable-vault.html">
	    Enable Vault
	  </a>
	</li>
	<li>
	  <a href="how-to-unseal-vault.html">
	    Unseal Vault
	  </a>
	</li>
      </ul>
      <strong>
	API reference
      </strong>
      <ul>
	<li>
	  <a href="api-authentication-reference.html">
	    API authentication
	  </a>
	</li>
	<li>
	  <a href="python-api-client-reference.html">
	    API client
	  </a>
	</li>
	<li>
	  <a href="../../api/docs">
	    API documentation
	  </a>
	</li>
      </ul>
      <strong>
	<a href="maas-technical-reference.html">
	  MAAS technical reference
	</a>
      </strong>
      <ul>
	<li>
	  <a href="commissioning-scripts-reference.html">
	    Commissioning scripts
	  </a>
	</li>
	<li>
	  <a href="hardware-test-scripts-reference.html">
	    Hardware test scripts
	  </a>
	</li>
	<li>
	  <a href="audit-event-log-reference.html">
	    Audit event logs
	  </a>
	</li>
	<li>
	  <a href="maas-performance.html">
	    MAAS performance
	  </a>
	</li>
	<li>
	  <a href="power-management-reference.html">
	    Power management
	  </a>
	</li>
	<li>
	  <a href="storage-layouts-reference.html">
	    Storage layouts
	  </a>
	</li>
	<li>
	  <a href="maas-terraform-provider-reference.html">
	    Terraform provider
	  </a>
	</li>
      </ul>
    </div>
    <div class="container" style="float:right; width:65%; margin-top:40px; margin-right:30px">
  <h1>MAAS glossary</h1><!-- "MAAS glossary" -->
<p>Built on a foundation of networking knowledge, MAAS introduces a number of new terms, and adds some nuances to common terms.  Some of these terms may be common networking terms you never looked up; others represent more complex concepts that may be unique to MAAS.  This article presents and explains some of these important terms.</p>
<p><details><summary>Show me an alphabetical list of terms</summary></p>
<ul style="margin-left:4px; list-style-type:disc;">
<li>
<p><a href="maas-glossary.html#heading--zones">Availability zones</a></p>
</li>
<li>
<p><a href="maas-glossary.html#heading--cloud-init">cloud-init</a></p>
</li>
<li>
<p><a href="maas-glossary.html#heading--controllers">Controller</a></p>
</li>
<li>
<p><a href="maas-glossary.html#heading--devices">Device</a></p>
</li>
<li>
<p><a href="maas-glossary.html#heading--dhcp">DHCP</a></p>
</li>
<li>
<p><a href="maas-glossary.html#heading--dhcp-relay">DHCP relay</a></p>
</li>
<li>
<p><a href="maas-glossary.html#heading--edge-clouds">Edge clouds</a></p>
</li>
<li>
<p><a href="maas-glossary.html#heading--fabrics">Fabrics</a></p>
</li>
<li>
<p><a href="maas-glossary.html#heading--images">Images</a></p>
</li>
<li>
<p><a href="maas-glossary.html#heading--interfaces">Interfaces</a></p>
</li>
<li>
<p><a href="maas-glossary.html#heading--isolcpus">isolcpus</a></p>
</li>
<li>
<p><a href="maas-glossary.html#heading--machines">Machine</a></p>
</li>
<li>
<p><a href="maas-glossary.html#heading--machine-actions">Machine actions</a></p>
</li>
<li>
<p><a href="maas-glossary.html#heading--machine-statuses">Machine statuses</a></p>
</li>
<li>
<p><a href="maas-glossary.html#heading--network-infrastructure">Network infrastructure</a></p>
</li>
<li>
<p><a href="maas-glossary.html#heading--network-interface">Network interface</a></p>
</li>
<li>
<p><a href="maas-glossary.html#heading--network-topology">Network topology</a></p>
</li>
<li>
<p><a href="maas-glossary.html#heading--numa">NUMA</a></p>
</li>
<li>
<p><a href="maas-glossary.html#heading--nodes">Nodes</a></p>
</li>
<li>
<p><a href="maas-glossary.html#heading--package-repositories">Package repositories</a></p>
</li>
<li>
<p><a href="maas-glossary.html#heading--regions">Regions</a></p>
</li>
<li>
<p><a href="maas-glossary.html#heading--series">Series</a></p>
</li>
<li>
<p><a href="maas-glossary.html#heading--spaces">Spaces</a></p>
</li>
<li>
<p><a href="maas-glossary.html#heading--sr-iov">SR-IOV</a></p>
</li>
<li>
<p><a href="maas-glossary.html#heading--tags">Tags</a></p>
</li>
<li>
<p><a href="maas-glossary.html#heading--ubuntu-package-repositories">Ubuntu package repositories</a></p>
</li>
<li>
<p><a href="maas-glossary.html#heading--vm-hosts">VM hosts</a>
</details></p>
</li>
</ul>
<p><a href="#heading--nodes"><h2 id="heading--nodes">Nodes</h2></a></p>
<p>A node is a general term that refers to multiple, more specific objects. Nodes are managed by MAAS through a life cycle, from adding and enlistment into MAAS, through commissioning, allocation and deployment. Nodes are then either released back into the pool of nodes or retired.</p>
<p>Nodes include the following classes of objects:</p>
<ul style="margin-left:4px; list-style-type:disc;">
<li>Controllers</li>
<li>Machines</li>
<li>Devices</li>
</ul>
<p>See <a href="#heading--machine-actions">Machine actions</a> and <a href="#heading--machine-statuses">Machine statuses</a> below for an overview of a node&rsquo;s life cycle.</p>
<p><a href="#heading--controllers"><h3 id="heading--controllers">Controllers</h3></a></p>
<p>There are two types of controllers: a region controller and a rack controller. The region controller deals with operator requests while one or more rack controllers provide the high-bandwidth services to multiple server racks, as typically found in a data centre.</p>
<p>A region controller consists of the following components:</p>
<ul style="margin-left:4px; list-style-type:disc;">
<li>REST API server (TCP port 5240)</li>
<li>PostgreSQL database</li>
<li>DNS</li>
<li>caching HTTP proxy</li>
<li>web UI</li>
</ul>
<p>Think of a region controller can as being responsible for a data centre, or a single region. Multiple fabrics are used by MAAS to accommodate subdivisions within a single region, such as multiple floors in a data centre.</p>
<p>A rack controller provides the following services:</p>
<ul style="margin-left:4px; list-style-type:disc;">
<li>DHCP</li>
<li>TFTP</li>
<li>HTTP (for images)</li>
<li>power management</li>
</ul>
<p>A rack controller is attached to each &ldquo;fabric&rdquo;. As the name implies, a typical setup is to have a rack controller in each data centre server rack. The rack controller will cache large items for performance, such as operating system install images, but maintains no independent state other than the credentials required to talk to the region controller.</p>
<p>Both the region controller and the rack controller can be scaled-out as well as made highly available.</p>
<p><a href="#heading--machines"><h3 id="heading--machines">Machines</h3></a></p>
<p>A machine is a node that can be deployed by MAAS.</p>
<p><a href="#heading--devices"><h3 id="heading--devices">Devices</h3></a></p>
<p>A device is a non-deployable node. This entity can be used to track routers, for example.</p>
<p>Static or dynamic IP addresses and DNS names can be assigned to any device or parent node.  These addresses will be automatically deleted when the parent node is deleted or released, along with any IP address reservations.  This arrangement is designed to model and manage the virtual machines or containers running inside a MAAS-deployed node.</p>
<p><a href="#heading--vm-hosts"><h2 id="heading--vm-hosts">VM hosts</h2></a></p>
<p>VM hosts, also called composable hardware, allow for the dynamic composition of machines from a pool of available hardware resources (e.g. disk space, memory, cores).</p>
<p><a href="#heading--zones"><h2 id="heading--zones">Zones</h2></a></p>
<p>A physical zone, or just zone, is an organisational unit that contains nodes where each node is in one, and only one, zone. Later, while in production, a node can be taken (allocated) from a specific zone (or not from a specific zone). Since zones, by nature, are custom-designed (except for the &lsquo;default&rsquo; zone), they provide more flexibility than a similar feature offered by a public cloud service (ex: availability zones).</p>
<p>Some prime examples of zone usage include fault-tolerance, service performance, and power management. </p>
<p>A newly installed MAAS comes with a default zone which contains all nodes unless you create a new zone. You can therefore safely ignore the entire concept if you&rsquo;re not interested in leveraging zones.</p>
<p>You cannot remove the &lsquo;default&rsquo; zone or change its name.</p>
<p><a href="#heading--regions"><h2 id="heading--regions">Regions</h2></a></p>
<p>A region is an organisational unit one level above a zone. It contains all information about all machines running in any possible zones. In particular, the PostgreSQL database runs at this level and maintains state for all these machines.</p>
<p><a href="#heading--series"><h2 id="heading--series">Series</h2></a></p>
<p>A series is essentially an operating system version. For Ubuntu, a series takes into account HWE kernels. In practical terms, a series manifests itself in the form of install images that are used to provision MAAS machines. The MAAS administrator can select series as desired.</p>
<p><a href="#heading--images"><h2 id="heading--images">Images</h2></a></p>
<p>An image is used to provision a machine. As soon as you install MAAS, images are imported based on what series you have selected.  MAAS won&rsquo;t work until it has imported the necessary images.</p>
<p><a href="#heading--fabrics"><h2 id="heading--fabrics">Fabrics</h2></a></p>
<p>A <strong>fabric</strong> connects VLANs.  If you understand a VLAN, you know that they permit network connections only between specific switch ports or specifically identified ports (&ldquo;tagged&rdquo; ports). Consequently, it would be impossible for two VLANs to communicate with each other.  A fabric makes these VLAN-to-VLAN connections possible.</p>
<p><details><summary>Take me on a quick, deep dive on fabrics</summary></p>
<p>We can illustrate a network fabric more easily by rewinding the term to one of its earliest uses: the early phone system.  In a telephone switchboard, subscriber lines (customer phone numbers) ran in a grid pattern in the back of the switchboard, but they didn&rsquo;t touch each other until the operator inserted the plugs of a patch cable to join them.  With some &ldquo;plugboards&rdquo; (what a switchboard was actually called), an operator could conference multiple lines by adding more patch cords.</p>
<p>These patch cords essentially acted like a VLAN, allowing only the subscribers whose lines were &ldquo;patched in&rdquo; to join the conversation. </p>
<p>But the switchboard only covered one exchange, that is, one three-digit phone number prefix.  If a subscriber wanted to conference someone from another exchange, there had to be patch from one exchange to another.  This was handled by a long-distance operator.  Each exchange had a more robust outgoing line, called a &ldquo;trunk line,&rdquo; that connected exchanges in some central place.  The long-distance operators could bridge trunks in a specific way, involving a local operator in each of the &ldquo;bridged&rdquo; exchanges.</p>
<p>By now, you&rsquo;re probably starting to recognise a lot of network terms, which is completely appropriate.  Almost all modern networking technology originated in the telephone system.</p>
<p>Now imagine that you want to conference in six people, two in each of three distant exchanges.  Each exchange operator had to patch two numbers and a trunk line.  The long-distance operator had to patch three trunks in a specific way that prevented the conversation from going out to all numbers attached to the trunk.  </p>
<p>The details of the method aren&rsquo;t particularly relevant here, but it usually involved a pair of &ldquo;bridge clips&rdquo; that connected non-adjacent wire-crossings, with an insulated portion that laid across wires that weren&rsquo;t meant to be connected.  It looked a lot like a little bridge when properly placed.</p>
<p>Think of each of the local exchange conferences as a VLAN; the long-distance operator&rsquo;s patch cables created what was called a &ldquo;fabric.&rdquo;  Our use of fabric is exactly the same idea: some number of private &ldquo;conversations&rdquo; (connections) connected to each other so that specific people in each &ldquo;group&rdquo; can all talk to each other. </p>
<p></details></p>
<p>You could describe a fabric as a VLAN namespace. It&rsquo;s a switch or a combination of switches that use trunking to provide access to specific VLANs. MAAS creates a default fabric (&lsquo;fabric-0&rsquo;) for each detected subnet during installation.</p>
<p>The following conceptual diagram shows two fabrics in the same data centre or region, each using distinct VLAN ranges and their associated subnets:</p>
<p><a href="https://discourse.maas.io/uploads/default/original/1X/46177305128bf7f3190f8a7bbd037c33e96f6a9e.png" target = "_blank"><img src="https://discourse.maas.io/uploads/default/original/1X/46177305128bf7f3190f8a7bbd037c33e96f6a9e.png"></a></p>
<p><a href="#heading--spaces"><h2 id="heading--spaces">Spaces</h2></a></p>
<p>A space is a logical grouping of subnets that can communicate with one another. Spaces can be arranged to group subnets according to various parameters.  One of the most common examples is a DMZ space, which might group subnets presenting a web interface to the public Internet.  Behind this DMZ would be specific applications that aren&rsquo;t allowed to interact directly with the user, but instead must interact with a Web UI in the DMZ space.  MAAS does not create a default space during installation.</p>
<p>Spaces facilitate machine allocation for <a href="https://jaas.ai/">Juju</a><code>↗</code>. See <a href="https://jaas.ai/docs/spaces">Juju network spaces</a><code>↗</code> for more details.</p>
<p><a href="#heading--tags"><h2 id="heading--tags">Tags</h2></a></p>
<p>A tag (not to be confused with VLAN tags) is user-created and associated with nodes based on their physical properties. These can then be used to identify nodes with particular abilities which can be useful during the deployment of services.</p>
<p><a href="#heading--subnets"><h2 id="heading--subnets">Subnets</h2></a></p>
<p>A subnet is a &ldquo;layer 3&rdquo; network, defined by a network address and a network mask length (in bits) and usually written in &ldquo;CIDR&rdquo; format. MAAS supports IPv4 and IPv6 subnets. Examples include:</p>
<pre><code class="language-no-highlight">- 0.0.0/8
- 16.0.0/12
- 168.0.0/16
2001:db8:4d41:4153::/64
</code></pre>
<p><a href="#heading--ip-ranges"><h3 id="heading--ip-ranges">IP ranges</h3></a></p>
<p>You can reserve IP addresses by adding one or more reserved ranges to a subnet configuration. You can define two types of ranges:</p>
<ul style="margin-left:4px; list-style-type:disc;">
<li><strong>Reserved range</strong> Mode operates differently depending on whether the subnet is managed or unmanaged:<ul style="margin-left:4px; list-style-type:disc;">
<li><strong>Managed (subnet)</strong>: MAAS will never assign IP addresses inside this range.  You can use this range for anything, such as infrastructure systems, network hardware, external DHCP, or an OpenStack namespace.</li>
<li><strong>Unmanaged (subnet)</strong>: MAAS will only assign IP addresses inside this range.</li>
</ul>
</li>
<li><strong>Reserved dynamic range</strong> An IP range that MAAS will use for enlisting, commissioning and, if enabled, MAAS-managed DHCP on the node&rsquo;s VLAN during commissioning, deploying. An initial range is created as part of the DHCP enablement process if done with the web UI. MAAS never uses IP addresses from this range for an unmanaged subnet.</li>
</ul>
<p><a href="#heading--dhcp-relay"><h2 id="heading--dhcp-relay">DHCP relay</h2></a></p>
<p>A DHCP relay, or relay agent, is a network device that forwards requests and replies between a DHCP client and a DHCP server when both are not on the same physical subnet.</p>
<p><a href="#heading--interfaces"><h2 id="heading--interfaces">Interfaces</h2></a></p>
<p><a href="#heading--physical"><h3 id="heading--physical">Physical</h3></a></p>
<p>After a node is commissioned, MAAS discovers its physical interfaces.</p>
<p>MAAS always creates a device with at least one physical interface.</p>
<p>Before deployment, a MAAS administrator can configure additional interfaces on the node, including one or more of the types mentioned below.</p>
<p><a href="#heading--bond"><h3 id="heading--bond">Bond</h3></a></p>
<p>A bond interface is capable of aggregating two or more physical interfaces into a single logical interface.  You can use bonds in conjunction with a managed switch (using Link Aggregation and Control Protocol, or LACP), or independently (software bonds).</p>
<p><a href="#heading--vlan"><h3 id="heading--vlan">VLAN</h3></a></p>
<p>A VLAN interface can be used to connect to a tagged VLAN, if the node is connected to an authorised port.</p>
<p><a href="#heading--unknown"><h3 id="heading--unknown">Unknown</h3></a></p>
<p>Unknown interfaces are sometimes discovered by MAAS. For example, a new DHCP lease that is not associated with any known node or device. Such an interface cannot be user-created.</p>
<p><a href="#heading--machine-actions"><h2 id="heading--machine-actions">Machine actions</h2></a></p>
<p>Machine actions are essentially &ldquo;things you can do with nodes&rdquo;. You can trigger them via the web UI or the MAAS CLI. In the web UI, you manage them with the &lsquo;Take action&rsquo; button in the top right corner. An action usually changes the status (see next section) of a node. Below is the full list of possible actions and their meaning, arranged alphabetically.</p>
<p><a href="#heading--abort"><h3 id="heading--abort">Abort</h3></a></p>
<p>You can abort any action that permits retries. Currently, only commissioning and deployment permit retries.</p>
<p><a href="#heading--allocate"><h3 id="heading--allocate">Allocate</h3></a></p>
<p>Allocates (reserves) a node to the MAAS user performing the action (and currently logged in). Changes a node&rsquo;s status from &lsquo;Ready&rsquo; to &lsquo;Allocated&rsquo;.</p>
<p>With the CLI, it is necessary to perform this action before deploying. With the web UI, it is done automatically for the user. Allocating in the web UI is used for machine reservation.</p>
<p><a href="#heading--commission"><h3 id="heading--commission">Commission</h3></a></p>
<p>This action commissions a node, changing a node&rsquo;s status from &lsquo;New&rsquo; to &lsquo;Commissioning&rsquo; to &lsquo;Ready&rsquo;.</p>
<p>Commissioning enables MAAS to build a detailed inventory of RAM, CPU, storage, NICs and accelerators like GPUs. These are itemised and usable as constraints for machine selection.</p>
<p>If commissioning is unsuccessful, the status becomes &lsquo;Failed commissioning&rsquo;.</p>
<p>Any time a node&rsquo;s underlying networking or disk subsystem has changed, it should be re-commissioned. Typically, you would mark the node as &lsquo;Broken&rsquo; (see below), implement maintenance, and then Commission.</p>
<p><a href="#heading--delete"><h3 id="heading--delete">Delete</h3></a></p>
<p>This action removes a node from MAAS. The underlying machine remains unaffected. Upon rebooting, it will be enlisted once more (status &lsquo;New&rsquo;).</p>
<p><a href="#heading--deploy"><h3 id="heading--deploy">Deploy</h3></a></p>
<p>This action, which includes &lsquo;Power on,&rsquo; deploys a node, changing a node&rsquo;s status from &lsquo;Ready&rsquo; (or &lsquo;Allocated&rsquo;) to a deployed status. </p>
<p>During deployment, MAAS turns on the machine and installs a complete server operating system without manual intervention, configuring network interfaces, disk partitions and more automatically.</p>
<p>If the deployment is unsuccessful, the status becomes &lsquo;Failed deployment&rsquo;.</p>
<p>Note that Juju, often used in conjunction with MAAS, also uses the term &ldquo;deploy&rdquo; to mean &ldquo;deploy an application&rdquo;.</p>
<p><a href="#heading--exit-rescue-mode"><h3 id="heading--exit-rescue-mode">Exit rescue mode</h3></a></p>
<p>This action changes a node&rsquo;s status from &lsquo;Rescue mode&rsquo; to the &lsquo;Exiting rescue mode&rsquo; transitory status and then back to its original status when the operation is complete.</p>
<p><a href="#heading--mark-broken"><h3 id="heading--mark-broken">Mark broken</h3></a></p>
<p>Marks a node as broken. Changes a node&rsquo;s status to &lsquo;Broken&rsquo;. Includes action &lsquo;Power off&rsquo;.</p>
<p>You can choose this action if any other action has failed (such as Commission and Deploy). If you mark a node broken, MAAS will not use it. This action would usually be followed by an investigation to determine the source of the problem.</p>
<p>By marking a node broken, you can also flag it for hardware maintenance that would affect MAAS, such as network or disk modifications. In this case, the original status would be &lsquo;Deployed&rsquo;.</p>
<p>You can also mark a newly-commissioned node (&lsquo;Ready&rsquo;) as &lsquo;Broken.&rsquo;</p>
<p><a href="#heading--mark-fixed"><h3 id="heading--mark-fixed">Mark fixed</h3></a></p>
<p>This action fixes a broken node, changing its status from &lsquo;Broken&rsquo; to &lsquo;Ready&rsquo;.</p>
<p><a href="#heading--lock"><h3 id="heading--lock">Lock</h3></a></p>
<p>This action marks a machine as locked, preventing the user from performing actions on machines that could change their state. For example, a locked machine cannot be mistakenly powered off or released.</p>
<p>A locked machine has a padlock symbol next to its name.</p>
<p><a href="https://discourse.maas.io/uploads/default/original/1X/7d1f0928fb599d465916e43e731535dfee60e65a.png" target = "_blank"><img src="https://discourse.maas.io/uploads/default/original/1X/7d1f0928fb599d465916e43e731535dfee60e65a.png"></a></p>
<p><a href="#heading--override-failed"><h3 id="heading--override-failed">Override failed</h3></a></p>
<p>Allows a machine marked as ‘Failed testing’ to be usable.</p>
<p><a href="#heading--power-off"><h3 id="heading--power-off">Power off</h3></a></p>
<p>This action turns off a node&rsquo;s underlying machine.</p>
<p><a href="#heading--power-on"><h3 id="heading--power-on">Power on</h3></a></p>
<p>This action turns on a node&rsquo;s underlying machine.</p>
<p><a href="#heading--release"><h3 id="heading--release">Release</h3></a></p>
<p>This action, which includes the &lsquo;Power off&rsquo; action, releases a node back into the pool of available nodes, changing a node&rsquo;s status from &lsquo;Deployed&rsquo; (or &lsquo;Allocated&rsquo;) to &lsquo;Ready&rsquo;.</p>
<p>The user has the opportunity to erase the node&rsquo;s storage (disks) before confirming the action. You can configure a default erasure setting on the &lsquo;Storage&rsquo; tab of the &lsquo;Settings&rsquo; page.</p>
<p><a href="#heading--rescue-mode"><h3 id="heading--rescue-mode">Rescue mode</h3></a></p>
<p>This action allows you to boot a node ephemerally (Ubuntu running in memory on the underlying machine). By doing so, you can SSH to the machine for maintenance purposes. This action works for a Deployed or Broken node, as well as for a node that failed to deploy.</p>
<p>Authentication and access to the node&rsquo;s storage work the same way it would if the node were deployed. The fact that ephemeral Ubuntu is running is entirely transparent to the user.</p>
<p>The node status is changed to the &lsquo;Entering rescue mode&rsquo; transitory status and then to &lsquo;Rescue mode&rsquo; when the operation is complete.</p>
<p><a href="#heading--set-zone"><h3 id="heading--set-zone">Set Zone</h3></a></p>
<p>This action puts the node in a specific zone.</p>
<p><a href="#heading--test-hardware"><h3 id="heading--test-hardware">Test hardware</h3></a></p>
<p>This action allows the user to select and run scripts to test a machine&rsquo;s underlying hardware.</p>
<p><a href="#heading--unlock"><h3 id="heading--unlock">Unlock</h3></a></p>
<p>This action releases a machine from a locked state.</p>
<p><a href="#heading--machine-statuses"><h2 id="heading--machine-statuses">Machine statuses</h2></a></p>
<p>Node statuses are labels used to describe the general state of a node as known to MAAS. A node will undergo various manipulations during their time spent in MAAS, and its status will change accordingly. Actions applied to a node are the most common cause of a status change (see section above.)  Below is the full list of status values and their meaning, arranged alphabetically.</p>
<p>Some aspects of a node can only be modified when a node has a certain status. Here are two typical examples:</p>
<ul style="margin-left:4px; list-style-type:disc;">
<li>you cannot modify a network interfaces unless the node has a status of either &lsquo;Ready&rsquo; or &lsquo;Broken&rsquo;.</li>
<li>you cannot modify storage unless the node has a status of either &lsquo;Ready&rsquo; or &lsquo;Allocated&rsquo;.</li>
</ul>
<p><a href="#heading--allocated"><h3 id="heading--allocated">Allocated</h3></a></p>
<p>The node is allocated (reserved) to a MAAS user. See node action &lsquo;Allocate&rsquo;.</p>
<p><a href="#heading--broken"><h3 id="heading--broken">Broken</h3></a></p>
<p>The node is broken. See node action &lsquo;Mark broken&rsquo;.</p>
<p><a href="#heading--commissioning"><h3 id="heading--commissioning">Commissioning</h3></a></p>
<p>The node is in the process of commissioning. See node action &lsquo;Commission&rsquo;.</p>
<p><a href="#heading--deployed"><h3 id="heading--deployed">Deployed</h3></a></p>
<p>The node is deployed. See node action &lsquo;Deploy&rsquo;.</p>
<p>The visible status will be the name of the chosen OS (e.g. &lsquo;Ubuntu 16.04 LTS&rsquo;).</p>
<p><a href="#heading--deploying"><h3 id="heading--deploying">Deploying</h3></a></p>
<p>The node is in the process of deploying. See node action &lsquo;Deploy&rsquo;.</p>
<p>The visible status will be Deploying to &lsquo;OS&rsquo;, where &lsquo;OS&rsquo; is the name of the OS being deployed (e.g. &lsquo;Deploying to Ubuntu 16.04 LTS&rsquo;).</p>
<p><a href="#heading--entering-rescue-mode"><h3 id="heading--entering-rescue-mode">Entering rescue mode</h3></a></p>
<p>The node is in the process of entering rescue mode. See node action &lsquo;Rescue mode&rsquo;.</p>
<p><a href="#heading--exiting-rescue-mode"><h3 id="heading--exiting-rescue-mode">Exiting rescue mode</h3></a></p>
<p>The node is in the process of exiting rescue mode. See node action &lsquo;Exit rescue mode&rsquo;.</p>
<p><a href="#heading--failed-commissioning"><h3 id="heading--failed-commissioning">Failed Commissioning</h3></a></p>
<p>The node failed to commission.</p>
<p><a href="#heading--failed-deployment"><h3 id="heading--failed-deployment">Failed Deployment</h3></a></p>
<p>The node failed to deploy.</p>
<p><a href="#heading--locked"><h3 id="heading--locked">Locked</h3></a></p>
<p>It&rsquo;s not strictly a status, but a machine showing a &lsquo;padlock&rsquo; symbol adjacent to its name is in a locked state.</p>
<p><a href="#heading--new"><h3 id="heading--new">New</h3></a></p>
<p>This status represents the first stage of a node&rsquo;s life in MAAS. Typically, a node with this status has just been added to MAAS.</p>
<p><a href="#heading--ready"><h3 id="heading--ready">Ready</h3></a></p>
<p>A node bearing this status has been commissioned and is ready for use, including the necessary BMC credentials. MAAS can start or stop this machine, and allocate or (re)deploy it with a fresh operating system.</p>
<p><a href="#heading--rescue-mode"><h3 id="heading--rescue-mode">Rescue mode</h3></a></p>
<p>The node is in rescue mode and is ready to accept SSH connections. See node action &lsquo;Rescue mode&rsquo;.</p>
<p><a href="#heading--package-repositories"><h2 id="heading--package-repositories">Package repositories</h2></a></p>
<p>Package repositories managed within MAAS can be of two types:</p>
<ul style="margin-left:4px; list-style-type:disc;">
<li>Ubuntu package repositories</li>
<li>Personal Package Archives (PPA)</li>
</ul>
<p>You can configure repositories in the &lsquo;Package repositories&rsquo; tab on the &lsquo;Settings&rsquo; page. Any enabled repository listed on this page will become automatically available to any subsequently deployed nodes.</p>
<p>MAAS further simplifies the addition of third-party repositories by also allowing the administrator to input their respective GPG keys here. This arrangement means that nodes will have instant access to these repositories (i.e. no need to import the keys into APT).</p>
<p>An added repository can be disabled and re-enabled using a toggle switch to the right of it.</p>
<p><a href="#heading--ubuntu-package-repositories"><h2 id="heading--ubuntu-package-repositories">Ubuntu package repositories</h2></a></p>
<p>An Ubuntu package repository is a repository that makes available Ubuntu packages to computers able to connect to it over the network, whether that network is private or public (e.g. the Internet).</p>
<p>MAAS comes equipped with the official Ubuntu repository <code>archive.ubuntu.com</code> as well as the equivalent for architectures other than i386 and amd64: <code>ports.ubuntu.com</code> as is evident in the default configuration below:</p>
<p><a href="https://assets.ubuntu.com/v1/77b93794-manage-repositories__2.4_default-repo-config.png" target = "_blank"><img src="https://assets.ubuntu.com/v1/77b93794-manage-repositories__2.4_default-repo-config.png"></a></p>
<p>Adding a third-party repository is elementary. Begin by basing the configuration on a line you would typically place in a system&rsquo;s <code>/etc/apt/sources.list</code> file. For instance, for the Google Chrome repository, the line would look like:</p>
<p><code>deb http://dl.google.com/linux/chrome/deb stable main</code></p>
<p>You will also need the GPG public key that is associated with the private key that signed this particular repository. Typically, the project&rsquo;s website is consulted to obtain this information. For this example, you could download the key like this:</p>
<pre><code class="language-bash">wget https://dl.google.com/linux/linux_signing_key.pub
</code></pre>
<p>The key now resides in the saved file <code>linux_signing_key.pub</code> for later use.</p>
<p>To add this repository, then, hit the &lsquo;Add repository&rsquo; button and fill in the fields using the gathered information. Note that the &lsquo;Name&rsquo; is an arbitrary label to give the repository.</p>
<p>Before saving, the form should look very similar to this:</p>
<p><a href="https://assets.ubuntu.com/v1/1aa1c512-manage-repositories__2.4_add-repo.png" target = "_blank"><img src="https://assets.ubuntu.com/v1/1aa1c512-manage-repositories__2.4_add-repo.png"></a></p>
<p>Click &lsquo;Add repository&rsquo; to save the configuration.</p>
<p>A private repository can be built to assist with offline operations, based on the official repository. This repository can also contain custom packages.</p>
<p><a href="#heading--personal-package-archives-ppa"><h2 id="heading--personal-package-archives-ppa">Personal Package Archives (PPA)</h2></a></p>
<p>A Personal Package Archive (PPA) is a <a href="https://launchpad.net">Launchpad</a>-based method for any individual (or team)<code>↗</code> to build and distribute packages for Ubuntu.</p>
<p>Adding a PPA is equally straightforward. Using the <a href="https://launchpad.net/~canonical-support/+archive/ubuntu/support-tools"><code>sosreport</code> PPA</a><code>↗</code> as an example, first retrieve the PPA&rsquo;s address from its page on Launchpad:</p>
<p><code>ppa:canonical-support/support-tools</code></p>
<p>Like before, a public GPG key will be needed. Also get this from the PPA&rsquo;s Launchpad page: &lsquo;Technical details about this PPA&rsquo; &gt; &lsquo;1024R/9360754F&rsquo; &gt; &lsquo;9360754F&rsquo;.</p>
<p>To add this PPA, then, hit the &lsquo;Add repository&rsquo; button and fill in the fields. Before saving, the form should look something like this:</p>
<p><a href="https://assets.ubuntu.com/v1/a0962e17-manage-repositories__2.4_add-ppa.png" target = "_blank"><img src="https://assets.ubuntu.com/v1/a0962e17-manage-repositories__2.4_add-ppa.png"></a></p>
<p>Click &lsquo;Add repository&rsquo; to save the configuration.</p>
<p>See <a href="https://help.launchpad.net/Packaging/PPA">Launchpad PPAs</a><code>↗</code> for more information on PPAs.</p>
<p><a href="#heading--numa"><h2 id="heading--numa">NUMA/vNUMA</h2></a></p>
<p>NUMA stands for &ldquo;Non-Uniform Memory Access.&rdquo;  In this context, &ldquo;non-uniform&rdquo; means that any given CPU core can access its dedicated memory faster than the memory dedicated to other cores.  A NUMA configuration groups core(s) and memory as a dedicated node, which reduces memory access times, so the core won&rsquo;t spend a lot of time stalled in wait states &ndash; that is, waiting for access to data in memory, either because the memory is relatively far away (proximity) or because other cores have access to the same memory (shared memory). In other words, NUMA works better when the core has dedicated memory that is relatively close by.</p>
<p>In this context, &ldquo;far away&rdquo; could mean physical distance (more wire or a longer bus distance), more interceding processes (as in virtual machines), or both.  The process of optimising thread and process scheduling so that the core running the code and the required data are close together is sometimes known as &ldquo;creating affinity.&rdquo; This affinity creates NUMA &ldquo;nodes,&rdquo; which can be treated as opaque nodes from a symmetric multi-processing (SMP) point of view.  Tasks are assigned to nodes to minimise overhead and wait states.</p>
<p>There is more flexibility in creating affinity when using virtual machines, because memory and core are constructs overlaid on existing hardware, rather than hard silicon.  While this seems as if it might make SMP easier, in fact, it creates difficulties because of the nature of virtual machines and the potential number of interceding processes that manage virtual memory.  For optimum performance, VMs should be aligned to a single NUMA node, so that resources are not split across nodes.</p>
<p>In practice, this means that VMs would be &ldquo;pinned&rdquo; to specific cores to create stability.  While the user has the choice of how to pin VMs, MAAS provides visual information that helps the user see how VMs are allocated to physical hardware, and make adjustments if that arrangement isn&rsquo;t (or turns out not to be) optimal.</p>
<p>If you want to dig deeper, there is a <a href="https://en.wikipedia.org/wiki/Non-uniform_memory_access">more through treatment of NUMA</a><code>↗</code> on Wikipedia.</p>
<p><a href="#heading--sr-iov"><h2 id="heading--sr-iov">SR-IOV</h2></a></p>
<p>With traditional ethernet, a packet comes into the NIC and interrupt is fired for the one core assigned to handle NIC interrupts.  That core has to go get the packet, find the destination MAC address or VLAN tag, then go interrupt the destination core &ndash; which has to get the packet and write it to the memory of the VM it&rsquo;s managing. Statistically speaking, that&rsquo;s basically two core interrupts for every incoming packet.</p>
<p>Many smart NICs are able to sort network packets into queues, based on MAC address or VLAN tag of the intended recipient, a technology sometimes known as &ldquo;VMDq&rdquo;.  In these cases, each queue has its own interrupt, so each core gets interrupted only for its own packets. This arrangement is much faster than having one core assigned to handle all network interrupts.  Even so, the hypervisor still has to copy every packet from the NIC to the VM, physically touching each packet.</p>
<p>With SR-IOV, it&rsquo;s possible to have no core interrupts when packets come in.  SR-IOV creates &ldquo;virtual functions,&rdquo; with dedicated queues for transmitting and receiving.  Each VM is directly assigned hardware resources via a virtual function driver, which knows how to DMA-copy data directly between the NIC and the memory space of the relevant VM. Essentially, SR-IOV is like a &ldquo;jumper wire&rdquo; between the NIC and the VM, bypassing the core.  This prevents interrupting the core when packets arrive for it, and significantly reduces the core workload when sending network packets.</p>
<p>For a deeper dive, try this <a href="https://www.youtube.com/watch?v=hRHsk8Nycdg">SR-IOV presentation</a><code>↗</code> from Intel.</p>
<p><a href="#heading--isolcpus"><h2 id="heading--isolcpus">Isolating CPUs</h2></a></p>
<p>For certain operations, it&rsquo;s useful to shield a CPU from having to execute general system processes and take interrupts.  These are sometimes referred to as &ldquo;isolcpus,&rdquo; more correctly described as booting a core with the <code>isolcpus</code> boot parameter.  This parameter restricts the shielded core to processes assigned directly to it, avoiding sharing bandwidth with the general scheduler and preventing the core from taking non-specific interrupts.</p>
<p>When used with VMs, users can maximise performance by configuring isolcpus in the kernel, to prevent the general scheduler and other tasks from using bandwidth on your VM core(s).</p>
<p><a href="#heading--edge-clouds"><h2 id="heading--edge-clouds">Edge clouds</h2></a></p>
<p>Edge clouds are designed to minimise latency, so that your cloud computing experience is nearer to real-time.  The use of &ldquo;edge&rdquo; doesn&rsquo;t specifically refer to the edges of the cloud, but to the machines that are at the &ldquo;edge of the problem,&rdquo; or more to the point, &ldquo;the edge of the cloud that is closest to your application.&rdquo;  Sometimes these are separate clouds in your own data centre, though they can also be parts of a remote cloud that are closer to you in network terms.</p>
<p>There are a number of complex decision lops and optimisation algorithms used by edge clouds, but the primary purpose is low-latency computing where possible.  If the servers closest to you (network-wise) can handle the load, they do; if not, they can call on other servers just a little further away.</p>
<p>Edge clouds can be planned and enhanced by using NUMA and SR-IOV techniques.  NUMA can help you create SMP nodes on VM cores the shortest (network) distance away from your application.  SR-IOV can, in general, reduce network latency even more by eliminating core involvement in network traffic. You can create virtual machines and assign NUMA nodes to minimise network latency, and then ensure that   MAAS gives you NUMA tools to find out whether you&rsquo;re achieving this sort of optimisation, and help you make decisions about how to adjust and improve over time.</p>
<p><a href="#heading--hugepages"><h2 id="heading--hugepages">Hugepages</h2></a></p>
<p>Computer memory is addressed not as raw RAM, but as virtual memory. Assisted by the CPU&rsquo;s memory management unit (MMU), the kernel maps virtual memory to a physical location. Virtual memory is divided into pages, which can be swapped in and out to disk during normal operation (hence the term &ldquo;swap space&rdquo;).  When programs access memory, the CPU needs to know which physical page has the data, so it relies on the kernel&rsquo;s &ldquo;page table&rdquo; to find the right virtual-to-physical address mapping.</p>
<p>Since this page table is big and slow, the CPU has a special buffer &ndash; the Translation Lookaside Buffer (TLB) &ndash; that caches address mapping.  This means after the first access to a page, subsequent accesses are much faster.  Since this buffer is implemented in hardware, for speed, the size is limited to, say, 4096 bytes.</p>
<p>When the core is accessing lots of pages, the speed advantage of the TLB can be lost.  Hugepages allow one TLB entry to point to 2MB, instead of just 4096 bytes.  With 512 TLB entries, typically, you can map 1GB of memory.  Hugepages come with a catch, though: if you have to swap pages, it (obviously) takes longer.</p>
<p>There&rsquo;s no tried and true formula for when to use them, but the key consideration is that you want to use most of a hugepage when you swap.  Rather than using little sections of a hugepage, which would mean losing the performance advantage from constant swapping, you want to maximise the use of each hugepage.  While there&rsquo;s no simple, empirical way to calculate this answer, you can do it by trial-and-error observation.</p>
<p>MAAS provides the dashboards and tools necessary to monitor and adjust your use of hugepages, so that you can find the right balance.</p>
<p><a href="#heading--network-tutorial"><h2 id="heading--network-tutorial">Brief network tutorial</h2></a></p>
<p>The following is a brief network tutorial, provided as a tool to synchronise understanding.  Note that this tutorial covers mostly those terms routinely needed in the course of using MAAS.</p>
<p><a href="#heading--dhcp"><h3 id="heading--dhcp">DHCP</h3></a></p>
<p>The Dynamic Host Control Protocol is a network management system in which a server (or group of servers) dynamically assigns IP addresses and other network parameters to a network device.  This network device may or may not have the capability to provide its own IP address, although to take advantage of DHCP, the device must have been configured to seek out a DHCP server and accept an assigned IP address.  Typically, a network administrator defines a range of reserved IP addresses from which the DHCP server can pull when assigning addresses.</p>
<p>DHCP operates using the four-step &ldquo;DORA&rdquo; model &ndash; Discovery, Offer, Request, and Acknowledge:</p>
<ul style="margin-left:4px; list-style-type:disc;">
<li>
<p>Potential DHCP clients broadcast a DHCPDISCOVER message on its attached subnet using destination address 255.255.255.255.</p>
</li>
<li>
<p>A connected DHCP server receives the DHCPDISCOVER message and sends a DHCPOFFER message, containing an IP address that the client may use.</p>
</li>
<li>
<p>The client replies with a DHCPREQUEST message, requesting the offered address.</p>
</li>
<li>
<p>The DHCP server responds with a DHCPACK (acknowledgement) which includes various important configuration parameters, such as the lease duration.</p>
</li>
</ul>
<p>Of course, there is <a href="https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol">much more to DHCP</a><code>↗</code>, but what&rsquo;s covered here should be sufficient understanding for using MAAS.</p>
<p><a href="#heading--network-interface"><h3 id="heading--network-interface">Network interface</h3></a></p>
<p>A network interface, often referred to as a &ldquo;network interface card&rdquo; or NIC, is either a separate physical card connected to a node, a set of circuits embedded on a node&rsquo;s motherboard, or a radio transceiver attached to a node in some way.  All network connections require a NIC.  The terms &ldquo;port&rdquo; and &ldquo;adaptor&rdquo; are also used to refer to a network interface.</p>
<p><a href="#heading--network-infrastructure"><h3 id="heading--network-infrastructure">Network infrastructure</h3></a></p>
<p>Network infrastructure is a catch-all term covering the physical components of a network, include cables, patch panels, switches, routers, hubs, and other associated network gear.</p>
<p><a href="#heading--cloud-init"><h2 id="heading--cloud-init">Cloud-init</h2></a></p>
<p>Cloud-init is the industry-standard method for initialising cloud instances, independent of platform.  It allows you to automatically provision operating system images, bringing them to a fully running state.  It also allows you to customise networking, storage, user space, applications, and various other components of a functioning system.</p>
<p>There are four stages of cloud-init action:</p>
<ul style="margin-left:4px; list-style-type:disc;">
<li>
<p>Local initialisation - this &ldquo;as-early-as-possible&rdquo; stage configures system elements that must be set up before the system can be made fully operational, such as networking configuration, including bridges, VLANs, bonds, and so forth.</p>
</li>
<li>
<p>Initialisation - this second stage runs as soon as the network connections are up and running, taking care of custom storage configurations, disk volume expansion, block device setup and filesystem allocations.</p>
</li>
<li>
<p>Module configuration - stage three configures the necessary meta-tools to allow full system configuration, such as SSH, apt/yum, and NTP.</p>
</li>
<li>
<p>Module finalisation - stage four is the very end of the boot process, installing packages and executing any user-supplied configuration scripts.</p>
</li>
</ul>
<p>These four steps combine (at least) four general datasources to bring an instance into being:</p>
<ul style="margin-left:4px; list-style-type:disc;">
<li>
<p>Disk image - the operating system for the instance; this is a bare-bones, uncustomised version of the chosen OS.</p>
</li>
<li>
<p>Metadata - this configuration information is supplied by the cloud provider, specifying things like disk images storage, networking, default users, and other basic customisations.</p>
</li>
<li>
<p>User data - data provided by end users or cloud administrators to initialise the instance.  This completely optional data can be anything from shell scripts to highly-structured cloud-config data that trigger cloud-init&rsquo;s built-ins.</p>
</li>
<li>
<p>Vendor data - data provided by cloud platform vendors; this is identical (in principle) to user data, but derived from a different source.  In practice, vendor data usually handle things that users wouldn&rsquo;t normally specify, such as mirror setup, NTP service management, etc.</p>
</li>
</ul>
    </div>
  </body>
</html>