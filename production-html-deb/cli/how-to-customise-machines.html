<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="css/stylesheet.css" />
    <style>
      #selector a:link{color:black;}
      #selector a:visited{color:black;}
      #selector a:active{color:black;}
      #selector a:hover{color:blue;}
      #sidebar a:link{color:black;}
      #sidebar a:visited{color:black;}
      #sidebar a:active{color:black;}
      #sidebar a:hover{color:blue;}
      ul {margin-left:0;list-style-type:none;}
      li {margin: 4px 0;}
    </style>
  </head>
  <body>
    <div id="selector" style="top:0; position:fixed; float:right; background-color:#d9d9d9; width:100%;border-bottom:1px solid black;">
      &nbsp;&nbsp;<strong>Offline docs</strong>
      <a href="https://maas.io/docs">(switch to live docs)</a>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<a href="../ui/how-to-customise-machines.html">
	  UI-only
	</a>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<a href="../cli/how-to-customise-machines.html">
	  CLI-only
	</a>
    </div>
    <div id="sidebar" style="float:left; width:25%;margin-top:40px; margin-left:20px">
      <strong>
	<a href="../maas-documentation-25.html">
	  Introduction
	</a>
      </strong>
      <ul>
	<li>
	  <a href="about-maas.html">
	    About MAAS
	  </a>
	</li>
	<li>
	  <a href="get-started-with-maas.html">
	    Get started with MAAS
	  </a>
	</li>
	<li>
	  <a href="how-to-install-maas.html">
	    Install MAAS
	  </a>
	</li>
	<li>
	  <a href="how-to-use-the-maas-cli.html">
	    Use the MAAS CLI
	  </a>
	</li>
      <strong>
	<a href="about-controllers.html">
	  Controllers
	</a>
      </strong>
      <ul>
	<li>
	  <a href="how-to-manage-racks.html">
	    Manage racks
	  </a>
	</li>
	<li>
	  <a href="how-to-manage-regions.html">
	    Region controllers
	  </a>
	</li>
	<li>
	  <a href="how-to-enable-high-availability.html">
	    Enable HA
	  </a>
	</li>
      </ul>
      <strong>
	<a href="about-machines.html">
	  Machines
	</a>
      </strong>
      <ul>
	<li>
	  <a href="how-to-manage-machines.html">
	    Manage machines
	  </a>
	</li>
	<li>
	  <a href="how-to-deploy-machines.html">
	    Deploy machines
	  </a>
	</li>
	<li>
	  <a href="how-to-customise-machines.html">
	    Customise machines
	  </a>
	</li>
      </ul>
      <strong>
	<a href="about-vm-hosting.html">
	  VM hosting
	</a>
      </strong>
      <ul>
	<li>
	  <a href="how-to-manage-vm-hosts.html">
	    Manage VM hosts
	  </a>
	</li>
	<li>
	  <a href="how-to-manage-vms.html">
	    Manage VMs
	  </a>
	</li>
	<li>
	  <a href="how-to-use-lxd.html">
	    Use LXD
	  </a>
	</li>
      </ul>
      <strong>
	<a href="about-networking.html">
	  Networking
	</a>
      </strong>
      <ul>
	<li>
	  <a href="how-to-manage-networks.html">
	    Manage networks
	  </a>
	</li>
	<li>
	  <a href="how-to-manage-machine-interfaces.html">
	    Manage interfaces
	  </a>
	</li>
	<li>
	  <a href="how-to-manage-dhcp.html">
	    Manage DHCP
	  </a>
	</li>
	<li>
	  <a href="how-to-manage-ip-ranges.html">
	    Manage IP ranges
	  </a>
	</li>
	<li>
	  <a href="how-to-manage-proxies.html">
	    Manage proxies
	  </a>
	</li>
	<li>
	  <a href="how-to-enable-tls-encryption.html">
	    Enable TLS
	  </a>
	</li>
	<li>
	  <a href="how-to-manage-availability-zones.html">
	    Manage zones
	  </a>
	</li>
	<li>
	  <a href="how-to-set-up-ntp.html">
	    Set up NTP
	  </a>
	</li>
	<li>
	  <a href="how-to-use-maas-in-an-air-gapped-environment.html">
	    Use air-gapped MAAS
	  </a>
	</li>
      </ul>
      <strong>
	<a href="about-images.html">
	  Images
	</a>
      </strong>
      <ul>
	<li>
	  <a href="how-to-import-images.html">
	    Select and import images
	  </a>
	</li>
	<li>
	  <a href="how-to-build-maas-images.html">
	    Build MAAS images
	  </a>
	</li>
	<li>
	  <a href="how-to-create-a-custom-ubuntu-image.html">
	    Create custom Ubuntu images
	  </a>
	</li>
	<li>
	  <a href="how-to-use-image-streams.html">
	    Use image streams
	  </a>
	</li>
	<li>
	  <a href="how-to-mirror-images-locally.html">
	    Mirror images locally
	  </a>
	</li>
	<li>
	  <a href="how-to-manage-vmware-images.html">
	    Manage VMWare images
	  </a>
	</li>
      </ul>
      <strong>
	<a href="about-tags-and-annotations.html">
	  Tags
	</a>
      </strong>
      <ul>
	<li>
	  <a href="how-to-manage-tags.html">
	    Manage tags
	  </a>
	</li>
	<li>
	  <a href="how-to-use-machine-tags.html">
	    Use machine tags
	  </a>
	</li>
	<li>
	  <a href="how-to-use-controller-tags.html">
	    Use controller tags
	  </a>
	</li>
	<li>
	  <a href="how-to-use-storage-tags.html">
	    Use storage tags
	  </a>
	</li>
	<li>
	  <a href="how-to-use-network-tags.html">
	    Use network tags
	  </a>
	</li>
      </ul>
	<p/>
	<strong>
	  Operations
	</strong>
	<ul>
	  <li>
	    <a href="how-to-set-up-prometheus-metrics.html">
	      Set up Prometheus
	    </a>
	  </li>
	  <li>
	  <a href="how-to-back-up-maas.html">
	    Back up MAAS
	  </a>
	</li>
	<li>
	  <a href="how-to-secure-maas.html">
	    Secure MAAS
	  </a>
	</li>
	<li>
	  <a href="how-to-manage-user-accounts.html">
	    Manage users
	  </a>
	</li>
	<li>
	  <a href="how-to-search-maas.html">
	    Search MAAS
	  </a>
	</li>
      </ul>
      <strong>
	Reference
      </strong>
      <ul>
	<li>
	  <a href="power-management-reference.html">
	    Power management
	  </a>
	</li>
	<li>
	  <a href="commissioning-scripts-reference.html">
	    Commissioning scripts
	  </a>
	</li>
	<li>
	  <a href="hardware-test-scripts-reference.html">
	    Hardware test scripts
	  </a>
	</li>
	<li>
	  <a href="maas-logging-reference.html">
	    Log files
	  </a>
	</li>
	<li>
	  <a href="api.html">
	    API reference
	  </a>
	</li>
	<li>
	  <a href="python-api-client-reference.html">
	    API client
	  </a>
	</li>
	<li>
	  <a href="api-authentication-reference.html">
	    API authentication
	  </a>
	</li>
	<li>
	  <a href="maas-concepts-and-terms-reference.html">
	    Concepts & terms
	  </a>
	</li>
      </ul>
      <strong>
	<a href="how-to-troubleshoot-maas.html">
	  Troubleshooting
	</a>
      </strong>
      <ul>
	<li>
	  <a href="how-to-get-help.html">
	    Get help
	  </a>
	</li>
	<li>
	  <a href="tips-and-tricks.html">
	    Tips, tricks, and traps
	  </a>
	</li>
	<li>
	  <a href="how-to-upgrade-maas.html">
	    Upgrade MAAS
	  </a>
	</li>
      </ul>
      <strong>
	<a href="what-is-new-with-maas.html">
	  Release notes
	</a>
      </strong>
      <p/>
      <strong>
	<a href="how-to-contact-us.html">
	  Contact us
	</a>
      </strong>
    </div>
    <div class="container" style="float:right; width:65%; margin-top:40px; margin-right:30px">
  <h1>How to customise machines</h1><p>MAAS machines can be customised in a number of ways, including:</p>
<ul>
<li>machine storage.</li>
<li>commissioning and deployment configurations (known as &ldquo;pre-seeding&rdquo;).</li>
<li>custom Ubuntu kernels.</li>
<li>kernel boot options.</li>
<li>resource pools.</li>
</ul>
<p>In this article, you can learn:</p>
<ul>
<li><a href="#heading--about-customising-machines">About customising machines</a></li>
<li><a href="#heading--how-to-customise-machines">How to customise machines</a></li>
</ul>
<p>In short, this article will explain these possible customisations, and provide detailed instructions on how to customise your own machines as desired.</p>
<p><a href="#heading--about-customising-machines"><h2 id="heading--about-customising-machines">About customising machines</h2></a></p>
<p>In this section, you&rsquo;ll learn:</p>
<ul>
<li><a href="#heading--about-customising-machine-storage">About customising machine storage</a></li>
<li><a href="#heading--about-pre-seeding">About pre-seeding</a> (customising commissioning and deployment)</li>
<li><a href="#heading--about-ubuntu-kernels">About Ubuntu kernels</a></li>
<li><a href="#heading--about-kernel-boot-options">About kernel boot options</a></li>
<li><a href="#heading--about-resource-pools">About resource pools</a></li>
</ul>
<p><a href="#heading--about-customising-machine-storage"><h2 id="heading--about-customising-machine-storage">About customising machine storage</h2></a></p>
<p>You have significant latitude when choosing the final storage configuration of a deployed machine. MAAS supports traditional disk partitioning, as well as more complex options such as LVM, RAID, and bcache. MAAS also supports UEFI as a boot mechanism.  This article explains boot mechanisms and layouts, and offers some advice on how to configure layouts and manage storage.</p>
<p>A machine&rsquo;s storage is dependant upon the underlying system&rsquo;s disks, but its configuration (i.e., disk usage) is the result of a storage template. In MAAS, this template is called a layout, and MAAS applies it to a machine during commissioning.  Once a layout is applied, a regular user can make modifications to a machine at the filesystem level to arrive at the machine&rsquo;s final storage configuration.  When a machine is no longer needed, a user can choose from among several disk erasure types before releasing it.</p>
<p>MAAS supports storage configuration for CentOS and RHEL deployments. Support includes RAID, LVM, and custom partitioning with different file systems (ZFS and bcache excluded). This support requires a newer version of Curtin, <a href="https://launchpad.net/ubuntu/+source/curtin">available as a PPA</a>&#128279;.</p>
<p><a href="#heading--about-uefi-booting"><h3 id="heading--about-uefi-booting">About UEFI booting</h3></a></p>
<p>Every layout type supports a machine booting with UEFI. In such a case, MAAS automatically creates an EFI boot partition (<code>/boot/efi</code>). Other than setting the machine to boot from UEFI, the user does not need to take any additional action.</p>
<p>[note type=&rdquo;negative&rdquo; status=&rdquo;Warning&rdquo;]
UEFI must be enabled or disabled for the lifespan of the machine. For example, do not enlist a machine with UEFI enabled, and then disable it before commissioning. It won&rsquo;t work!
[/note]</p>
<p>The EFI partition, if created, will be the first partition (<code>sda1</code>) and will have a FAT32 filesystem with a size of 512 MB.</p>
<p><a href="#heading--about-block-devices"><h3 id="heading--about-block-devices">About block devices</h3></a></p>
<p>Once the initial storage layout has been configured on a machine, you can perform many operations to view and adjust the entire storage layout for the machine. In MAAS there are two different types of block devices.</p>
<p><strong>Physical</strong></p>
<p>A physical block device is a physically attached block device such as a 100GB hard drive connected to a server.</p>
<p><strong>Virtual</strong></p>
<p>A virtual block device is a block device that is exposed by the Linux kernel when an operation is performed. Almost all the operations on a physical block device can be performed on a virtual block device, such as a RAID device exposed as md0.</p>
<p><a href="#heading--about-partitions"><h3 id="heading--about-partitions">About partitions</h3></a></p>
<p>As with block devices (see <a href="#heading--about-block-devices">Block devices</a>), MAAS and the MAAS API offer a great deal of control over the creation, formatting, mounting and deletion of partitions.</p>
<p><a href="#heading--about-storage-restrictions"><h3 id="heading--about-storage-restrictions">About storage restrictions</h3></a></p>
<p>There are three restrictions for the storage configuration:</p>
<ol>
<li>An EFI partition is required to be on the boot disk for UEFI.</li>
<li>You cannot place partitions on logical volumes.</li>
<li>You cannot use a logical volume as a Bcache backing device.</li>
</ol>
<p>Violating these restrictions will prevent a successful deployment.</p>
<p><a href="#heading--about-vmfs-datastores"><h3 id="heading--about-vmfs-datastores">About VMFS datastores</h3></a></p>
<p>MAAS can configure custom local VMware VMFS Datastore layouts to maximise the usage of your local disks when deploying VMware ESXi. As VMware ESXi requires specific partitions for operating system usage, you must first apply the VMFS6 storage layout. This layout creates a VMFS Datastore named <code>datastore1</code> which uses the disk space left over on the boot disk after MAAS creates the operating system partitions.</p>
<p><a href="#heading--final-storage-modifications"><h3 id="heading--final-storage-modifications">About final storage modifications</h3></a></p>
<p>Once MAAS provisions a machine with block devices, via a layout or administrator customisation, a regular user can modify the resulting storage configuration at the filesystem level.</p>
<p><a href="#heading--about-disk-erasure"><h3 id="heading--about-disk-erasure">About disk erasure</h3></a></p>
<p>Disk erasure pertains to the erasing of data on each of a machine&rsquo;s disks when the machine has been released (see <a href="maas-concepts-and-terms-reference-5409.html#heading--release">Release action</a>) back into the pool of available machines. The user can choose from among three erasure types before confirming the Release action. A default erasure configuration can also be set.</p>
<p><a href="#heading--about-disk-erasure-types"><h4 id="heading--about-disk-erasure-types">About disk erasure types</h4></a></p>
<p>The three disk erasure types are:</p>
<ol>
<li>Standard erasure - Overwrites all data with zeros.</li>
<li>Secure erasure - Although effectively equivalent to Standard erase, Secure erase is much faster because the disk&rsquo;s firmware performs the operation. Because of this, however, some disks may not be able to perform this erasure type (SCSI, SAS, and FC disks in particular).</li>
<li>Quick erasure - Same as Standard erase but only targets the first 1 MB and the last 1 MB of each disk. This removes the partition tables and/or superblock from the disk, making data recovery difficult but not impossible.</li>
</ol>
<p>If all three options are checked when the machine is released the following order of preference is applied:</p>
<ol>
<li>Use &lsquo;secure erase&rsquo; if the disk supports it</li>
<li>If it does not then use &lsquo;quick erase&rsquo;</li>
</ol>
<p>It is very important to pay close attention to your selections when erasing disks.</p>
<p><a href="#heading--about-pre-seeding"><h2 id="heading--about-pre-seeding">About pre-seeding</h2></a></p>
<p>During machine <a href="about-machines-5083.html">enlistment</a>, <a href="how-to-deploy-machines-5115.html">deployment</a>, commissioning and machine installation, MAAS sends <a href="https://raw.githubusercontent.com/ravenac95/tempita/master/docs/index.txt">Tempita-derived</a>&#128279; configuration files to the <a href="https://launchpad.net/cloud-init">cloud-init</a>&#128279; process running on the target machine. MAAS refers to this process as <strong>preseeding</strong>. These preseed files are used to configure a machine&rsquo;s ephemeral and installation environments and can be modified or augmented to a custom machine configuration.</p>
<p>Preseeding in MAAS can be achieved in two ways:</p>
<ol>
<li>
<p><a href="https://launchpad.net/curtin">Curtin</a>&#128279;, a preseeding system similar to Kickstart or d-i (Debian Installer), applies customisation during operating system (OS) image installation. MAAS performs these changes on deployment, during OS installation, but before the machine reboots into the installed OS. Curtin customisations are perfect for administrators who want their deployments to have identical setups all the time, every time. <a href="https://blog.ubuntu.com/2017/06/02/customising-maas-installs">This blog post</a>&#128279; contains an excellent high-level overview of custom MAAS installs using Curtin.</p>
</li>
<li>
<p><a href="https://launchpad.net/cloud-init">Cloud-init</a>&#128279;, a system for setting up machines immediately after instantiation. cloud-init applies customisations after the first boot, when MAAS changes a machine&rsquo;s status to &lsquo;Deployed.&rsquo; Customisations are per-instance, meaning that user-supplied scripts must be re-specified on redeployment. Cloud-init customisations are the best way for MAAS users to customise their deployments, similar to how the various cloud services prepare VMs when launching instances.</p>
</li>
</ol>
<p><a href="#heading--templates"><h3 id="heading--templates">About templates</h3></a></p>
<p>The <a href="https://raw.githubusercontent.com/ravenac95/tempita/master/docs/index.txt">Tempita</a>&#128279; template files are found in the <code>/etc/maas/preseeds/</code> directory on the region controller. Each template uses a filename prefix that corresponds to a particular phase of MAAS machine deployment:</p>
<table>
<thead>
<tr>
<th align="left">Phase</th>
<th align="left">Filename prefix</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Enlistment</td>
<td align="left">enlist</td>
</tr>
<tr>
<td align="left">Commissioning</td>
<td align="left">commissioning</td>
</tr>
<tr>
<td align="left">Installation</td>
<td align="left">curtin (<a href="https://launchpad.net/curtin">Curtin</a>)</td>
</tr>
</tbody>
</table>
<p>Additionally, the template for each phase typically consists of two files. The first is a higher-level file that often contains little more than a URL or a link to further credentials, while a second file contains the executable logic.</p>
<p>The <code>enlist</code> template, for example, contains only minimal variables, whereas <code>enlist_userdata</code> includes both user variables and initialisation logic.</p>
<p>[note]
Tempita’s inheritance mechanism is the reverse of what you might expect. Inherited files, such as <code>enlist_userdata</code>, become the new template which can then reference variables from the higher-level file, such as <code>enlist</code>.
[/note]</p>
<p><a href="#heading--template-naming"><h3 id="heading--template-naming">About template naming</h3></a></p>
<p>MAAS interprets templates in lexical order by their filename.  This order allows for base configuration options and parameters to be overridden based on a combination of operating system, architecture, sub-architecture, release, and machine name.</p>
<p>Some earlier versions of MAAS only support Ubuntu. If the machine operating system is Ubuntu, then filenames without <code>{os}</code> will also be tried, to maintain backward compatibility.</p>
<p>Consequently, template files are interpreted in the following order:</p>
<ol>
<li>
<p><code>{prefix}_{os}_{node_arch}_{node_subarch}_{release}_{node_name}</code> or <code>{prefix}_{node_arch}_{node_subarch}_{release}_{node_name}</code></p>
</li>
<li>
<p><code>{prefix}_{os}_{node_arch}_{node_subarch}_{release}</code> or <code>{prefix}_{node_arch}_{node_subarch}_{release}</code></p>
</li>
<li>
<p><code>{prefix}_{os}_{node_arch}_{node_subarch}</code> or <code>{prefix}_{node_arch}_{node_subarch}</code></p>
</li>
<li>
<p><code>{prefix}_{os}_{node_arch}</code> or <code>{prefix}_{node_arch}</code></p>
</li>
<li>
<p><code>{prefix}_{os}</code></p>
</li>
<li>
<p><code>{prefix}</code></p>
</li>
<li>
<p><code>generic</code></p>
</li>
</ol>
<p>The machine needs to be the machine name, as shown in the web UI URL.</p>
<p>The prefix can be either <code>enlist</code>, <code>enlist_userdata</code>, <code>commissioning</code>, <code>curtin</code>, <code>curtin_userdata</code> or <code>preseed_master</code>. Alternatively, you can omit the prefix and the following underscore.</p>
<p>For example, to create a generic configuration template for Ubuntu 16.04 Xenial running on an x64 architecture, the file would need to be called <code>ubuntu_amd64_generic_xenial_node</code>.</p>
<p>To create the equivalent template for curtin_userdata, the file would be called <code>curtin_userdata_ubuntu_amd64_generic_xenial_node</code>.</p>
<p>[note]
Any file targeting a specific machine will replace the values and configuration held within any generic files. If those values are needed, you will need to copy these generic template values into your new file.
[/note]</p>
<p><a href="#heading--about-ubuntu-kernels"><h2 id="heading--about-ubuntu-kernels">About Ubuntu kernels</h2></a></p>
<p>MAAS supports four types of kernels for its Ubuntu machines:</p>
<ol>
<li>General availability kernels</li>
<li>Hardware enablement kernels</li>
<li>Hardware enablement kernels (pre-release)</li>
<li>Low latency kernels</li>
</ol>
<p><a href="#heading--general-availability-kernels"><h3 id="heading--general-availability-kernels">About general availability kernels</h3></a></p>
<p>The <em>general availability</em> (GA) kernel is based on the <em>generic</em> kernel that ships with a new Ubuntu version. Subsequent fixes are applied regularly by the &lsquo;stable&rsquo; <em>stream</em> used when setting up the global image source for MAAS.</p>
<p>MAAS denotes a GA kernel like this:</p>
<p><code>ga-&lt;version&gt;</code>: The GA kernel reflects the major kernel version of the shipped Ubuntu release. For example, &lsquo;ga-16.04&rsquo; is based on the &lsquo;generic&rsquo; 4.4 Ubuntu kernel. As per Ubuntu policy, a GA kernel will never have its major version upgraded until the underlying release is upgraded.</p>
<p><a href="#heading--hardware-enablement-kernels"><h3 id="heading--hardware-enablement-kernels">About hardware enablement kernels</h3></a></p>
<p>New hardware gets released all the time. If an Ubuntu host runs an older kernel, it&rsquo;s unlikely that MAAS can support the hardware. Canonical does make every effort to back-port more recent kernels enabling more hardware. The acronym HWE stands for &ldquo;Hardware Enablement.&rdquo;</p>
<p>You also gain kernel improvements and new features when installing an HWE kernel.</p>
<p>[note]
There is the notion of an HWE <em>stack</em>, which refers to the window manager and kernel when the Ubuntu host is running a desktop environment. HWE stacks do not apply to MAAS since machines are provisioned strictly as non-graphical servers.
[/note]</p>
<p>Note that these back-ported/HWE kernels are only available for LTS releases (e.g. Trusty, Xenial, etc.). For example, the first available HWE kernel for Ubuntu 16.04 LTS (Xenial) will be the GA kernel from Ubuntu 16.10 (Yakkety).</p>
<p>Before MAAS 2.1 on Xenial, HWE kernels are referred to by the notation <code>hwe-&lt;release letter&gt;</code>. So, to install the Yakkety HWE kernel on Xenial, the <code>hwe-y</code> kernel is used. By default, when using the web UI, MAAS imports all available HWE kernels along with its generic boot images. So if you are importing Trusty images, then the following HWE kernels are included: <code>hwe-u</code>, <code>hwe-v</code>, <code>hwe-w</code>, <code>hwe-x</code> (presuming the Xenial HWE kernel is available).</p>
<p>In MAAS 2.1, starting with Xenial kernels, the notation has changed. The following is used to refer to the latest HWE kernel available for Xenial: <code>hwe-16.04</code>.</p>
<p>See <a href="https://wiki.ubuntu.com/Kernel/LTSEnablementStack">LTS Enablement Stack</a>&#128279; (Ubuntu wiki) for the latest information on HWE.</p>
<p><a href="#heading--hardware-enablement-kernels-pre-release"><h3 id="heading--hardware-enablement-kernels-pre-release">About pre-release hardware enablement kernels</h3></a></p>
<p>The pre-release HWE kernel is known as the <em>edge</em> HWE kernel.</p>
<p>MAAS denotes the edge kernel like this: <code>hwe-&lt;version&gt;-edge</code>.</p>
<p>So &lsquo;hwe-16.04&rsquo; is considered older than &lsquo;hwe-16.04-edge&rsquo;.</p>
<p>See <a href="https://wiki.ubuntu.com/Kernel/RollingLTSEnablementStack#hwe-16.04-edge">Rolling LTS Enablement Stack</a>&#128279; (Ubuntu wiki) for more information.</p>
<p><a href="#heading--low-latency-kernels"><h3 id="heading--low-latency-kernels">About low latency kernels</h3></a></p>
<p>The low-latency kernel is based on the GA kernel, but uses a more aggressive configuration to reduce latency. It is categorised as a soft real-time kernel. For more information, see <a href="https://en.wikipedia.org/wiki/Real-time_computing#Criteria_for_real-time_computing">Criteria for real-time computing</a>&#128279; (Wikipedia).</p>
<p>MAAS denotes a low latency kernel in three ways:</p>
<ol>
<li><code>hwe-x-lowlatency</code>: the Xenial low latency HWE kernel for Trusty</li>
<li><code>ga-16.04-lowlatency</code>: the low latency GA kernel for Xenial</li>
<li><code>hwe-16.04-lowlatency</code>: the low latency HWE kernel for Xenial</li>
</ol>
<p><a href="#heading--using-kernels"><h3 id="heading--using-kernels">About choosing a kernel</h3></a></p>
<p>The kernel installed on a machine during deployment is, by default, the Ubuntu release&rsquo;s native kernel (GA). However, it is possible to tell MAAS to use a different kernel. Via the Web UI, MAAS can help you choose one of these kernels.  There are three different contexts for your choice:</p>
<ol>
<li>globally (default minimum enlistment and commissioning kernel)</li>
<li>per machine (minimum deploy kernel)</li>
<li>per machine during deployment (specific deploy kernel)</li>
</ol>
<p><a href="#heading--about-kernel-boot-options"><h2 id="heading--about-kernel-boot-options">About kernel boot options</h2></a></p>
<p>MAAS can specify kernel boot options to machines on both a global basis (UI and CLI) and a per-machine basis (CLI-only). A full catalogue of available options can be found in the <a href="https://www.kernel.org/doc/html/latest/admin-guide/kernel-parameters.html">Linux kernel parameters list</a>&#128279; at <a href="https://www.kernel.org">kernel.org</a>&#128279;.</p>
<p><a href="#heading--about-resource-pools"><h2 id="heading--about-resource-pools">About resource pools</h2></a></p>
<p>Resource pools allow administrators to logically group resources &ndash; machines and VM hosts &ndash; into pools. Pools can help you budget machines for a particular set of functions.  For example, if you&rsquo;re using MAAS to manage a hospital data centre, you may want to keep a certain number of machines reserved for provider use, whether that be for the charts, documentation, or orders application.  You can use resource pools to reserve those machines, regardless of which of the three applications you end up loading onto a particular machine at any given time. </p>
<p>Administrators can manage resource pools on the Machines page in the web UI, under the Resource pools tab, or with the MAAS CLI.   Also note that all MAAS installations have a resource pool named &ldquo;default.&rdquo; MAAS automatically adds new machines to the default resource pool.</p>
<p><a href="#heading--how-to-customise-machines"><h2 id="heading--how-to-customise-machines">How to customise machines</h2></a></p>
<p>If you want to customise machines, you may want to know:</p>
<ul>
<li><a href="#heading--how-to-customise-machine-storage">How to customise machine storage</a></li>
<li><a href="#heading--how-to-pre-seed-with-curtin">How to pre-seed with curtin</a></li>
<li><a href="#heading--cloud-init">How to pre-seed with cloud-init</a></li>
<li><a href="#heading--how-to-choose-ubuntu-kernels">How to choose Ubuntu kernels</a></li>
<li><a href="#heading--how-to-set-global-kernel-boot-options">How to set global kernel boot options</a></li>
<li><a href="#heading--how-to-use-resource-pools">How to use resource pools</a></li>
</ul>
<p><a href="#heading--how-to-customise-machine-storage"><h2 id="heading--how-to-customise-machine-storage">How to customise machine storage</h2></a></p>
<p>This section will show you:</p>
<ul>
<li><a href="#heading--how-to-set-global-storage-layouts">How to set global storage layouts</a></li>
<li><a href="#heading--how-to-set-per-machine-storage-layouts">How to set per-machine storage layouts</a></li>
<li><a href="#heading--how-to-erase-disks">How to erase disks</a></li>
<li><a href="#heading--how-to-specify-conditional-erasure-types">How to specify conditional erasure types</a></li>
<li><a href="#heading--how-to-list-block-devices">How to list block devices</a></li>
<li><a href="#heading--how-to-read-a-block-device">How to read a block device</a></li>
<li><a href="#heading--how-to-create-a-block-device">How to create a block device</a></li>
<li><a href="#heading--how-to-update-a-block-device">How to update a block device</a></li>
<li><a href="#heading--how-to-delete-a-block-device">How to delete a block device</a></li>
<li><a href="#heading--format-block-device">How to format a block device</a></li>
<li><a href="#heading--how-to-unformat-a-block-device">How to unformat a block device</a></li>
<li><a href="#heading--how-to-mount-a-block-device">How to mount a block device</a></li>
<li><a href="#heading--how-to-unmount-a-block-device">How to unmount a block device</a></li>
<li><a href="#heading--how-to-set-a-block-device-as-a-boot-disk">How to set a block device as a boot disk</a></li>
<li><a href="#heading--how-to-list-partitions">How to list partitions</a></li>
<li><a href="#heading--how-to-create-a-partition">How to create a partition</a></li>
<li><a href="#heading--how-to-delete-a-partition">How to delete a partition</a></li>
<li><a href="#heading--how-to-format-a-partition">How to format a partition</a></li>
<li><a href="#heading--how-to-unformat-a-partition">How to unformat a partition</a></li>
<li><a href="#heading--how-to-mount-a-partition">How to mount a partition</a></li>
<li><a href="#heading--how-to-unmount-a-partition">How to unmount a partition</a></li>
<li><a href="#heading--how-to-list-vmfs-datastores">How to list VMFS datastores</a></li>
<li><a href="#heading--how-to-view-a-vmfs-datastore">How to view a VMFS datastore</a></li>
<li><a href="#heading--how-to-create-a-vmfs-datastore">How to create a VMFS datastore</a></li>
<li><a href="#heading--how-to-edit-a-vmfs-datastore">How to edit a VMFS datastore</a></li>
<li><a href="#heading--how-to-delete-a-vmfs-datastore">How to delete a VMFS datastore</a></li>
</ul>
<p>Note that layouts can be set globally and on a per-machine basis.  For additional information on storage layouts, see the <a href="#heading--storage-layouts-reference">Storage layouts reference</a> section at the end of this article.</p>
<p><a href="#heading--how-to-set-global-storage-layouts"><h3 id="heading--how-to-set-global-storage-layouts">How to set global storage layouts</h3></a></p>
<p>All machines will have a default layout applied when commissioned. To set the default storage layout for all machines:</p>
<pre><code>maas $PROFILE maas set-config name=default_storage_layout value=$LAYOUT_TYPE
</code></pre>
<p>For example, to set the default layout to Flat:</p>
<pre><code>maas $PROFILE maas set-config name=default_storage_layout value=flat
</code></pre>
<p>Important: The new default will only apply to newly-commissioned machines.</p>
<p>[note type=&rdquo;caution&rdquo; status=&rdquo;Important&rdquo;]
The new default will only apply to newly-commissioned machines.
[/note]</p>
<p><a href="#heading--how-to-set-per-machine-storage-layouts"><h3 id="heading--how-to-set-per-machine-storage-layouts">How to set per-machine storage layouts</h3></a></p>
<p>An administrator can set a storage layout for a machine with a status of ‘Ready’ like this:</p>
<pre><code>maas $PROFILE machine set-storage-layout $SYSTEM_ID storage_layout=$LAYOUT_TYPE [$OPTIONS]
</code></pre>
<p>For example, to set an LVM layout where the logical volume has a size of 5 GB:</p>
<pre><code>maas $PROFILE machine set-storage-layout $SYSTEM_ID storage_layout=lvm lv_size=5368709120

</code></pre>
<p>You must specify all storage sizes in bytes.</p>
<p>This action will remove the configuration that may exist on any block device.</p>
<p>[note]
Only an administrator can modify storage at the block device level (providing the machine has a status of &lsquo;Ready&rsquo;).
[/note]</p>
<p><a href="#heading--how-to-erase-disks"><h3 id="heading--how-to-erase-disks">How to erase disks</h3></a></p>
<p>When using the MAAS CLI, you can erase a disk when releasing an individual machine.  Note that this option is not available when releasing multiple machines, so you&rsquo;ll want to make sure you&rsquo;re using:</p>
<pre><code>maas $PROFILE machine release...
</code></pre>
<p>and not:</p>
<pre><code>maas $PROFILE machines release...
</code></pre>
<p>Note the difference in singular and plural &ldquo;machine/machines&rdquo; in the commands.  Releasing a machine requires that you have the <code>system_id</code> of the machine to be released, which you can obtain with a command like this one:</p>
<pre><code>maas admin machines read | jq -r '([&quot;HOSTNAME&quot;,&quot;SYSID&quot;,&quot;POWER&quot;,&quot;STATUS&quot;,
&quot;OWNER&quot;, &quot;TAGS&quot;, &quot;POOL&quot;, &quot;VLAN&quot;,&quot;FABRIC&quot;,&quot;SUBNET&quot;] | (., map(length*&quot;-&quot;))),
(.[] | [.hostname, .system_id, .power_state, .status_name, .owner // &quot;-&quot;, 
.tag_names[0] // &quot;-&quot;, .pool.name,
.boot_interface.vlan.name, .boot_interface.vlan.fabric,
.boot_interface.links[0].subnet.name]) | @tsv' | column -t
</code></pre>
<p><a href="images/a496ac76977909f3403160ca96a1bb7224e785f5.jpeg" target = "_blank"><img alt="unlabeled image" width="690" src="images/a496ac76977909f3403160ca96a1bb7224e785f5.jpeg">
</a></p>
<p>The basic form of the release command, when erasing disks on releasing, is:</p>
<pre><code>maas $PROFILE machine release $SYSTEM_ID comment=&quot;some comment&quot; erase=true [secure_erase=true ||/&amp;&amp; quick_erase=true]
</code></pre>
<p>Parameters <code>secure_erase</code> and <code>quick_erase</code> are both optional, although if you don&rsquo;t specify either of them, the entire disk will be overwritten with null bytes.  Note that this overwrite process is very slow.</p>
<p>Secure erasure uses the drive&rsquo;s secure erase feature, if it has one.  In some cases, this can be much faster than overwriting the entire drive.  Be aware, though, that some drives implement secure erasure as a complete drive overwrite, so this method may still be very slow.  Additionally, if you specify secure erasure and the drive doesn&rsquo;t have this feature, you&rsquo;ll get a complete overwrite anyway &ndash; again, possibly very slow.</p>
<p>Quick erasure wipes 2MB at the start and end of the drive to make recovery both inconvenient and unlikely to happen by accident.  Note, though, that quick erasure is not secure.</p>
<p><a href="#heading--how-to-specify-conditional-erasure-types"><h3 id="heading--how-to-specify-conditional-erasure-types">How to specify conditional erasure types</h3></a></p>
<p>If you specify both erasure types, like this:</p>
<pre><code>maas $PROFILE machine release $SYSTEM_ID comment=&quot;some comment&quot; erase=true secure_erase=true quick_erase=true
</code></pre>
<p>then MAAS will perform a secure erasure if the drive has that feature; if not, it will perform a quick erasure.  Of course, if you&rsquo;re concerned about completely erasing the drive, and you&rsquo;re not sure whether the disk has secure erase features, the best way to handle that is to specify nothing, and allow the full disk to be overwritten by null bytes:</p>
<pre><code>maas $PROFILE machine release $SYSTEM_ID comment=&quot;some comment&quot; erase=true
</code></pre>
<p><a href="#heading--how-to-list-block-devices"><h3 id="heading--how-to-list-block-devices">How to list block devices</h3></a></p>
<p>To view all block devices on a machine use the read operation. This list both physical and virtual block devices, as you can see in the output from the following command:</p>
<pre><code class="language-bash">maas admin block-devices read &lt;node-id&gt;
</code></pre>
<p>Output:</p>
<pre><code class="language-nohighlight">Success.
Machine-readable output follows:
[
    {
        &quot;id&quot;: 10,
        &quot;path&quot;: &quot;/dev/disk/by-dname/vda&quot;,
        &quot;serial&quot;: &quot;&quot;,
        &quot;block_size&quot;: 4096,
        &quot;available_size&quot;: 0,
        &quot;resource_uri&quot;: &quot;/MAAS/api/2.0/nodes/4y3h8a/blockdevices/10/&quot;,
        &quot;filesystem&quot;: null,
        &quot;id_path&quot;: &quot;/dev/vda&quot;,
        &quot;size&quot;: 5368709120,
        &quot;partition_table_type&quot;: &quot;MBR&quot;,
        &quot;model&quot;: &quot;&quot;,
        &quot;type&quot;: &quot;physical&quot;,
        &quot;uuid&quot;: null,
        &quot;used_size&quot;: 5365563392,
        &quot;used_for&quot;: &quot;MBR partitioned with 1 partition&quot;,
        &quot;partitions&quot;: [
            {
                &quot;bootable&quot;: false,
                &quot;id&quot;: 9,
                &quot;resource_uri&quot;:&quot;/MAAS/api/2.0/nodes/4y3h8a/blockdevices/10/partition/9&quot;,
                &quot;path&quot;: &quot;/dev/disk/by-dname/vda-part1&quot;,
                &quot;uuid&quot;: &quot;aae082cd-8be0-4a64-ab49-e998abd6ea43&quot;,
                &quot;used_for&quot;: &quot;LVM volume for vgroot&quot;,
                &quot;size&quot;: 5360320512,
                &quot;type&quot;: &quot;partition&quot;,
                &quot;filesystem&quot;: {
                    &quot;uuid&quot;: &quot;a56ebfa6-8ef4-48b5-b6bc-9f9d27065d24&quot;,
                    &quot;mount_options&quot;: null,
                    &quot;label&quot;: null,
                    &quot;fstype&quot;: &quot;lvm-pv&quot;,
                    &quot;mount_point&quot;: null
                }
            }
        ],
        &quot;tags&quot;: [
            &quot;rotary&quot;
        ],
        &quot;name&quot;: &quot;vda&quot;
    },
    {
        &quot;id&quot;: 11,
        &quot;path&quot;: &quot;/dev/disk/by-dname/lvroot&quot;,
        &quot;serial&quot;: null,
        &quot;block_size&quot;: 4096,
        &quot;available_size&quot;: 0,
        &quot;resource_uri&quot;: &quot;/MAAS/api/2.0/nodes/4y3h8a/blockdevices/11/&quot;,
        &quot;filesystem&quot;: {
            &quot;uuid&quot;: &quot;7181a0c0-9e16-4276-8a55-c77364d137ca&quot;,
            &quot;mount_options&quot;: null,
            &quot;label&quot;: &quot;root&quot;,
            &quot;fstype&quot;: &quot;ext4&quot;,
            &quot;mount_point&quot;: &quot;/&quot;
        },
        &quot;id_path&quot;: null,
        &quot;size&quot;: 3221225472,
        &quot;partition_table_type&quot;: null,
        &quot;model&quot;: null,
        &quot;type&quot;: &quot;virtual&quot;,
        &quot;uuid&quot;: &quot;fc8ba89e-9149-412c-bcea-e596eb7c0d14&quot;,
        &quot;used_size&quot;: 3221225472,
        &quot;used_for&quot;: &quot;ext4 formatted filesystem mounted at /&quot;,
        &quot;partitions&quot;: [],
        &quot;tags&quot;: [],
        &quot;name&quot;: &quot;vgroot-lvroot&quot;
    }
]
</code></pre>
<p><a href="#heading--how-to-read-a-block-device"><h3 id="heading--how-to-read-a-block-device">How to read a block device</h3></a></p>
<p>If you want to read just one block device instead of listing all block devices the read operation on the block device endpoint provides that information. To display the details on device &lsquo;11&rsquo; from the previous output, for example, we could enter:</p>
<pre><code class="language-bash">maas admin block-device read &lt;node-id&gt; 11
</code></pre>
<p>The above command generates the following output:</p>
<pre><code class="language-nohighlight">Success.
Machine-readable output follows:
{
    &quot;available_size&quot;: 0,
    &quot;path&quot;: &quot;/dev/disk/by-dname/vgroot-lvroot&quot;,
    &quot;name&quot;: &quot;vgroot-lvroot&quot;,
    &quot;used_for&quot;: &quot;ext4 formatted filesystem mounted at /&quot;,
    &quot;type&quot;: &quot;virtual&quot;,
    &quot;used_size&quot;: 3221225472,
    &quot;filesystem&quot;: {
        &quot;uuid&quot;: &quot;7181a0c0-9e16-4276-8a55-c77364d137ca&quot;,
        &quot;mount_point&quot;: &quot;/&quot;,
        &quot;mount_options&quot;: null,
        &quot;fstype&quot;: &quot;ext4&quot;,
        &quot;label&quot;: &quot;root&quot;
    },
    &quot;id_path&quot;: null,
    &quot;id&quot;: 11,
    &quot;partition_table_type&quot;: null,
    &quot;block_size&quot;: 4096,
    &quot;tags&quot;: [],
    &quot;resource_uri&quot;: &quot;/MAAS/api/2.0/nodes/4y3h8a/blockdevices/11/&quot;,
    &quot;uuid&quot;: &quot;fc8ba89e-9149-412c-bcea-e596eb7c0d14&quot;,
    &quot;serial&quot;: null,
    &quot;partitions&quot;: [],
    &quot;size&quot;: 3221225472,
    &quot;model&quot;: null
}
</code></pre>
<p>It is also possible to use the name of the block device, such as &lsquo;sda&rsquo; or &lsquo;vda&rsquo;, instead of its &lsquo;id&rsquo;:</p>
<pre><code class="language-bash">s admin block-device read &lt;node-id&gt; vda
</code></pre>
<p>[note]
MAAS allows the name of a block device to be changed. If the block device name has changed then the API call needs to use the new name.
[/note]</p>
<pre><code>Using the ID is safer as it never changes.
</code></pre>
<p><a href="#heading--how-to-create-a-block-device"><h3 id="heading--how-to-create-a-block-device">How to create a block device</h3></a></p>
<p>MAAS gathers the required information itself on block devices when re- commissioning a machine. If this doesn&rsquo;t provide the required information, it is also possible - though not recommended - for an administrator to use the API to manually add a physical block device to a machine.</p>
<pre><code class="language-bash">maas admin block-devices create &lt;node-id&gt; name=vdb model=&quot;QEMU&quot; serial=&quot;QM00001&quot; size=21474836480 block_size=4096
</code></pre>
<p>Depending on your configuration, output should be similar to the following:</p>
<pre><code class="language-nohighlight">Success.
Machine-readable output follows:
{
    &quot;available_size&quot;: 21474836480,
    &quot;path&quot;: &quot;/dev/disk/by-dname/vdb&quot;,
    &quot;name&quot;: &quot;vdb&quot;,
    &quot;used_for&quot;: &quot;Unused&quot;,
    &quot;type&quot;: &quot;physical&quot;,
    &quot;used_size&quot;: 0,
    &quot;filesystem&quot;: null,
    &quot;id_path&quot;: &quot;&quot;,
    &quot;id&quot;: 12,
    &quot;partition_table_type&quot;: null,
    &quot;block_size&quot;: 4096,
    &quot;tags&quot;: [],
    &quot;resource_uri&quot;: &quot;/MAAS/api/2.0/nodes/4y3h8a/blockdevices/12/&quot;,
    &quot;uuid&quot;: null,
    &quot;serial&quot;: &quot;QM00001&quot;,
    &quot;partitions&quot;: [],
    &quot;size&quot;: 21474836480,
    &quot;model&quot;: &quot;QEMU&quot;
}
</code></pre>
<p>[note]
The serial number is what MAAS will use when a machine is deployed to find the specific block device. It&rsquo;s important that this be correct. In a rare chance that your block device does not provide a model or serial number you can provide an id_path. The id_path should be a path that is always the same, no matter the kernel version.
[/note]</p>
<p><a href="#heading--how-to-update-a-block-device"><h3 id="heading--how-to-update-a-block-device">How to update a block device</h3></a></p>
<p>An administrator can also update the details held on a physical block device, such as its name, from the API:</p>
<pre><code class="language-bash">maas admin block-device update &lt;node-id&gt; 12 name=newroot
</code></pre>
<p>Output from this command will show that the &lsquo;name&rsquo; has changed:</p>
<pre><code class="language-nohighlight">Success.
Machine-readable output follows:
{
    &quot;block_size&quot;: 4096,
    &quot;size&quot;: 21474836480,
    &quot;filesystem&quot;: null,
    &quot;model&quot;: &quot;QEMU&quot;,
    &quot;name&quot;: &quot;newroot&quot;,
    &quot;partitions&quot;: [],
    &quot;tags&quot;: [],
    &quot;used_size&quot;: 0,
    &quot;path&quot;: &quot;/dev/disk/by-dname/newroot&quot;,
    &quot;id_path&quot;: &quot;&quot;,
    &quot;uuid&quot;: null,
    &quot;available_size&quot;: 21474836480,
    &quot;id&quot;: 12,
    &quot;used_for&quot;: &quot;Unused&quot;,
    &quot;type&quot;: &quot;physical&quot;,
    &quot;resource_uri&quot;: &quot;/MAAS/api/2.0/nodes/4y3h8a/blockdevices/12/&quot;,
    &quot;partition_table_type&quot;: null,
    &quot;serial&quot;: &quot;QM00001&quot;
}
</code></pre>
<p><a href="#heading--how-to-delete-a-block-device"><h3 id="heading--how-to-delete-a-block-device">How to delete a block device</h3></a></p>
<p>Physical and virtual block devices can be deleted by an administrator, while ordinary users can only delete virtual block devices:</p>
<pre><code class="language-bash">maas admin block-device delete &lt;node-id&gt; 12
</code></pre>
<p><a href="#heading--format-block-device"><h3 id="heading--format-block-device">How to format a block device</h3></a></p>
<p>An entire block device can be formatted by defining a filesystem with the &lsquo;format&rsquo; API call:</p>
<pre><code class="language-bash">maas admin block-device format &lt;node-id&gt; 11 fstype=ext4
</code></pre>
<p>Successful output from this command will look similar to this:</p>
<pre><code class="language-nohighlight">Success.
Machine-readable output follows:
{
    &quot;block_size&quot;: 4096,
    &quot;size&quot;: 3221225472,
    &quot;filesystem&quot;: {
        &quot;label&quot;: &quot;&quot;,
        &quot;fstype&quot;: &quot;ext4&quot;,
        &quot;mount_options&quot;: null,
        &quot;uuid&quot;: &quot;75e42f49-9a45-466c-8425-87a40e4f4148&quot;,
        &quot;mount_point&quot;: null
    },
    &quot;model&quot;: null,
    &quot;name&quot;: &quot;vgroot-lvroot&quot;,
    &quot;partitions&quot;: [],
    &quot;tags&quot;: [],
    &quot;used_size&quot;: 3221225472,
    &quot;path&quot;: &quot;/dev/disk/by-dname/vgroot-lvroot&quot;,
    &quot;id_path&quot;: null,
    &quot;uuid&quot;: &quot;fc8ba89e-9149-412c-bcea-e596eb7c0d14&quot;,
    &quot;available_size&quot;: 0,
    &quot;id&quot;: 11,
    &quot;used_for&quot;: &quot;Unmounted ext4 formatted filesystem&quot;,
    &quot;type&quot;: &quot;virtual&quot;,
    &quot;resource_uri&quot;: &quot;/MAAS/api/2.0/nodes/4y3h8a/blockdevices/11/&quot;,
    &quot;partition_table_type&quot;: null,
    &quot;serial&quot;: null
}
</code></pre>
<p>[note]
You cannot format a block device that contains partitions or is used to make another virtual block device.
[/note]</p>
<p><a href="#heading--how-to-unformat-a-block-device"><h3 id="heading--how-to-unformat-a-block-device">How to unformat a block device</h3></a></p>
<p>You can remove the filesystem from a block device with the &lsquo;unformat&rsquo; API call:</p>
<pre><code class="language-bash">maas admin block-device unformat &lt;node-id&gt; 11
</code></pre>
<p>The output from this command should show the filesystem is now &lsquo;null&rsquo;:</p>
<pre><code class="language-nohighlight">Success.
Machine-readable output follows:
{
    &quot;available_size&quot;: 3221225472,
    &quot;path&quot;: &quot;/dev/disk/by-dname/vgroot-lvroot&quot;,
    &quot;name&quot;: &quot;vgroot-lvroot&quot;,
    &quot;used_for&quot;: &quot;Unused&quot;,
    &quot;type&quot;: &quot;virtual&quot;,
    &quot;used_size&quot;: 0,
    &quot;filesystem&quot;: null,
    &quot;id_path&quot;: null,
    &quot;id&quot;: 11,
    &quot;partition_table_type&quot;: null,
    &quot;block_size&quot;: 4096,
    &quot;tags&quot;: [],
    &quot;resource_uri&quot;: &quot;/MAAS/api/2.0/nodes/4y3h8a/blockdevices/11/&quot;,
    &quot;uuid&quot;: &quot;fc8ba89e-9149-412c-bcea-e596eb7c0d14&quot;,
    &quot;serial&quot;: null,
    &quot;partitions&quot;: [],
    &quot;size&quot;: 3221225472,
    &quot;model&quot;: null
}
</code></pre>
<p><a href="#heading--how-to-mount-a-block-device"><h3 id="heading--how-to-mount-a-block-device">How to mount a block device</h3></a></p>
<p>If a block device has a filesystem, you can use the &lsquo;maas&rsquo; command to mount a block devices at a given mount point:</p>
<pre><code class="language-bash">maas admin block-device mount &lt;node-id&gt; 11 mount_point=/srv
</code></pre>
<p>The mount point is included in the successful output from the command:</p>
<pre><code class="language-nohighlight">Success.
Machine-readable output follows:
{
    &quot;available_size&quot;: 0,
    &quot;path&quot;: &quot;/dev/disk/by-dname/vgroot-lvroot&quot;,
    &quot;name&quot;: &quot;vgroot-lvroot&quot;,
    &quot;used_for&quot;: &quot;ext4 formatted filesystem mounted at /srv&quot;,
    &quot;type&quot;: &quot;virtual&quot;,
    &quot;used_size&quot;: 3221225472,
    &quot;filesystem&quot;: {
        &quot;uuid&quot;: &quot;6f5965ad-49f7-42da-95ff-8000b739c39f&quot;,
        &quot;mount_point&quot;: &quot;/srv&quot;,
        &quot;mount_options&quot;: &quot;&quot;,
        &quot;fstype&quot;: &quot;ext4&quot;,
        &quot;label&quot;: &quot;&quot;
    },
    &quot;id_path&quot;: null,
    &quot;id&quot;: 11,
    &quot;partition_table_type&quot;: null,
    &quot;block_size&quot;: 4096,
    &quot;tags&quot;: [],
    &quot;resource_uri&quot;: &quot;/MAAS/api/2.0/nodes/4y3h8a/blockdevices/11/&quot;,
    &quot;uuid&quot;: &quot;fc8ba89e-9149-412c-bcea-e596eb7c0d14&quot;,
    &quot;serial&quot;: null,
    &quot;partitions&quot;: [],
    &quot;size&quot;: 3221225472,
    &quot;model&quot;: null
}
</code></pre>
<p><a href="#heading--how-to-unmount-a-block-device"><h3 id="heading--how-to-unmount-a-block-device">How to unmount a block device</h3></a></p>
<p>To remove the mount point from the block device, use the &lsquo;unmount&rsquo; call:</p>
<pre><code class="language-bash">maas admin block-device unmount &lt;node-id&gt; 11 mount_point=/srv
</code></pre>
<p>The previous command will include a nullified &lsquo;mount_point&rsquo; in its output:</p>
<pre><code class="language-nohighlight">Success.
Machine-readable output follows:
{
    &quot;available_size&quot;: 0,
    &quot;path&quot;: &quot;/dev/disk/by-dname/vgroot-lvroot&quot;,
    &quot;name&quot;: &quot;vgroot-lvroot&quot;,
    &quot;used_for&quot;: &quot;Unmounted ext4 formatted filesystem&quot;,
    &quot;type&quot;: &quot;virtual&quot;,
    &quot;used_size&quot;: 3221225472,
    &quot;filesystem&quot;: {
        &quot;uuid&quot;: &quot;6f5965ad-49f7-42da-95ff-8000b739c39f&quot;,
        &quot;mount_point&quot;: null,
        &quot;mount_options&quot;: null,
        &quot;fstype&quot;: &quot;ext4&quot;,
        &quot;label&quot;: &quot;&quot;
    },
    &quot;id_path&quot;: null,
    &quot;id&quot;: 11,
    &quot;partition_table_type&quot;: null,
    &quot;block_size&quot;: 4096,
    &quot;tags&quot;: [],
    &quot;resource_uri&quot;: &quot;/MAAS/api/2.0/nodes/4y3h8a/blockdevices/11/&quot;,
    &quot;uuid&quot;: &quot;fc8ba89e-9149-412c-bcea-e596eb7c0d14&quot;,
    &quot;serial&quot;: null,
    &quot;partitions&quot;: [],
    &quot;size&quot;: 3221225472,
    &quot;model&quot;: null
}
</code></pre>
<p><a href="#heading--how-to-set-a-block-device-as-a-boot-disk"><h3 id="heading--how-to-set-a-block-device-as-a-boot-disk">How to set a block device as a boot disk</h3></a></p>
<p>By default, MAAS picks the first added block device to the machine as the boot disk. In most cases this works as expected as the BIOS usually enumerates the boot disk as the first block device. There are cases where this fails and the boot disk needs to be set to another disk. This API allow setting which block device on a machine MAAS should use as the boot disk.:</p>
<pre><code class="language-bash">maas admin block-device set-boot-disk &lt;node-id&gt; 10
</code></pre>
<p>[note]
Only an administrator can set which block device should be used as the boot disk and only a physical block device can be set as as the boot disk. This operation should be done before a machine is acquired or the storage layout will be applied to the previous boot disk.
[/note]</p>
<p><a href="#heading--how-to-list-partitions"><h3 id="heading--how-to-list-partitions">How to list partitions</h3></a></p>
<p>To view all the partitions on a block device, use the &lsquo;partitions read&rsquo; API call:</p>
<pre><code class="language-bash">maas admin partitions read &lt;node-id&gt; 10
</code></pre>
<pre><code class="language-nohighlight">Success.
Machine-readable output follows:
[
    {
        &quot;bootable&quot;: false,
        &quot;id&quot;: 9,
        &quot;resource_uri&quot;:
&quot;/MAAS/api/2.0/nodes/4y3h8a/blockdevices/10/partition/9&quot;,
        &quot;path&quot;: &quot;/dev/disk/by-dname/vda-part1&quot;,
        &quot;uuid&quot;: &quot;aae082cd-8be0-4a64-ab49-e998abd6ea43&quot;,
        &quot;used_for&quot;: &quot;LVM volume for vgroot&quot;,
        &quot;size&quot;: 5360320512,
        &quot;type&quot;: &quot;partition&quot;,
        &quot;filesystem&quot;: {
            &quot;uuid&quot;: &quot;a56ebfa6-8ef4-48b5-b6bc-9f9d27065d24&quot;,
            &quot;mount_options&quot;: null,
            &quot;label&quot;: null,
            &quot;fstype&quot;: &quot;lvm-pv&quot;,
            &quot;mount_point&quot;: null
        }
    }
]
</code></pre>
<p>To view the metadata for a specific partition on a block device, rather than all partitions, use the singular &lsquo;partition&rsquo; API call with an endpoint:</p>
<pre><code class="language-bash">maas admin partition read &lt;node-id&gt; 10 9
</code></pre>
<p><a href="#heading--how-to-create-a-partition"><h3 id="heading--how-to-create-a-partition">How to create a partition</h3></a></p>
<p>To create a new partition on a block device, use the &lsquo;create&rsquo; API call:</p>
<pre><code class="language-bash">maas admin partitions create &lt;node-id&gt; 10 size=5360320512
</code></pre>
<p>In addition to bytes, as shown above, the &lsquo;size&rsquo; of a partition can also be defined with a &lsquo;G&rsquo; for gigabytes or &lsquo;M&rsquo; for megabytes. The output from the previous command will look like this:</p>
<pre><code class="language-nohighlight">Success.
Machine-readable output follows:
{
    &quot;bootable&quot;: false,
    &quot;path&quot;: &quot;/dev/disk/by-dname/vda-part1&quot;,
    &quot;filesystem&quot;: null,
    &quot;used_for&quot;: &quot;Unused&quot;,
    &quot;type&quot;: &quot;partition&quot;,
    &quot;id&quot;: 10,
    &quot;size&quot;: 5360320512,
    &quot;resource_uri&quot;: &quot;/MAAS/api/2.0/nodes/4y3h8a/blockdevices/10/partition/10&quot;,
    &quot;uuid&quot;: &quot;3d32adbf-9943-4785-ab38-963758338c6c&quot;
}
</code></pre>
<p><a href="#heading--how-to-delete-a-partition"><h3 id="heading--how-to-delete-a-partition">How to delete a partition</h3></a></p>
<p>Partitions can be deleted from a block device with the &lsquo;delete&rsquo; API call. Make sure you double check the partition details as the partition is deleted immediately, with no further confirmation:</p>
<pre><code class="language-bash">maas admin partition delete &lt;node-id&gt; 10 9
</code></pre>
<p>Successful output from the &lsquo;delete&rsquo; command will look like this:</p>
<pre><code class="language-bash">Success.
Machine-readable output follows:
</code></pre>
<p><a href="#heading--how-to-format-a-partition"><h3 id="heading--how-to-format-a-partition">How to format a partition</h3></a></p>
<p>Partitions can be formatted in a similar way to block devices:</p>
<pre><code class="language-bash">maas admin partition format &lt;node-id&gt; 10 9 fstype=ext4
</code></pre>
<p>The output from the &lsquo;format&rsquo; command will be similar to the following:</p>
<pre><code class="language-nohighlight">Success.
Machine-readable output follows:
{
    &quot;id&quot;: 9,
    &quot;used_for&quot;: &quot;Unmounted ext4 formatted filesystem&quot;,
    &quot;resource_uri&quot;: &quot;/MAAS/api/2.0/nodes/4y3h8a/blockdevices/10/partition/9&quot;,
    &quot;path&quot;: &quot;/dev/disk/by-dname/vda-part1&quot;,
    &quot;uuid&quot;: &quot;aae082cd-8be0-4a64-ab49-e998abd6ea43&quot;,
    &quot;size&quot;: 5360320512,
    &quot;bootable&quot;: false,
    &quot;type&quot;: &quot;partition&quot;,
    &quot;filesystem&quot;: {
        &quot;uuid&quot;: &quot;ea593366-be43-4ea3-b2d5-0adf82085a62&quot;,
        &quot;mount_point&quot;: null,
        &quot;mount_options&quot;: null,
        &quot;fstype&quot;: &quot;ext4&quot;,
        &quot;label&quot;: &quot;&quot;
    }
}
</code></pre>
<p>[note]
You cannot format partitions that are used to make another virtual block device.
[/note]</p>
<p><a href="#heading--how-to-unformat-a-partition"><h3 id="heading--how-to-unformat-a-partition">How to unformat a partition</h3></a></p>
<p>You can also remove the filesystem from a partition with the &lsquo;unformat&rsquo; API call:</p>
<pre><code class="language-bash">maas admin partition unformat &lt;node-id&gt; 10 10 fstype=ext4
</code></pre>
<pre><code class="language-nohighlight">Success.
Machine-readable output follows:
{
    &quot;bootable&quot;: false,
    &quot;path&quot;: &quot;/dev/disk/by-dname/vda-part1&quot;,
    &quot;filesystem&quot;: null,
    &quot;used_for&quot;: &quot;Unused&quot;,
    &quot;type&quot;: &quot;partition&quot;,
    &quot;id&quot;: 10,
    &quot;size&quot;: 5360320512,
    &quot;resource_uri&quot;: &quot;/MAAS/api/2.0/nodes/4y3h8a/blockdevices/10/partition/10&quot;,
    &quot;uuid&quot;: &quot;3d32adbf-9943-4785-ab38-963758338c6c&quot;
}
</code></pre>
<p><a href="#heading--how-to-mount-a-partition"><h3 id="heading--how-to-mount-a-partition">How to mount a partition</h3></a></p>
<p>A formatted partition can be mounted at a given mount point with the &lsquo;mount&rsquo; command.</p>
<pre><code class="language-bash">maas admin partition mount &lt;node-id&gt; 10 10 mount_point=/srv
</code></pre>
<p>The mount point and the filesystem is visible in the output from the command:</p>
<pre><code class="language-nohighlight">Success.
Machine-readable output follows:
{
    &quot;bootable&quot;: false,
    &quot;id&quot;: 10,
    &quot;resource_uri&quot;: &quot;/MAAS/api/2.0/nodes/4y3h8a/blockdevices/10/partition/10&quot;,
    &quot;path&quot;: &quot;/dev/disk/by-dname/vda-part1&quot;,
    &quot;uuid&quot;: &quot;3d32adbf-9943-4785-ab38-963758338c6c&quot;,
    &quot;used_for&quot;: &quot;ext4 formatted filesystem mounted at /srv&quot;,
    &quot;size&quot;: 5360320512,
    &quot;type&quot;: &quot;partition&quot;,
    &quot;filesystem&quot;: {
        &quot;uuid&quot;: &quot;1949a5fb-f7bd-4ada-8ba5-d06d3f5857a8&quot;,
        &quot;mount_options&quot;: &quot;&quot;,
        &quot;label&quot;: &quot;&quot;,
        &quot;fstype&quot;: &quot;ext4&quot;,
        &quot;mount_point&quot;: &quot;/srv&quot;
    }
}
</code></pre>
<p><a href="#heading--how-to-unmount-a-partition"><h3 id="heading--how-to-unmount-a-partition">How to unmount a partition</h3></a></p>
<p>A previous mounted partition can be unmounted with the &lsquo;unmount&rsquo; command:</p>
<pre><code class="language-bash">maas admin partition unmount 4y3h8a 10 10
</code></pre>
<p>After successfully running this command, the mount point will show as &lsquo;null&rsquo; in the output:</p>
<pre><code class="language-nohighlight">Success.
Machine-readable output follows:
{
    &quot;bootable&quot;: false,
    &quot;id&quot;: 10,
    &quot;resource_uri&quot;: &quot;/MAAS/api/2.0/nodes/4y3h8a/blockdevices/10/partition/10&quot;,
    &quot;path&quot;: &quot;/dev/disk/by-dname/vda-part1&quot;,
    &quot;uuid&quot;: &quot;3d32adbf-9943-4785-ab38-963758338c6c&quot;,
    &quot;used_for&quot;: &quot;Unmounted ext4 formatted filesystem&quot;,
    &quot;size&quot;: 5360320512,
    &quot;type&quot;: &quot;partition&quot;,
    &quot;filesystem&quot;: {
        &quot;uuid&quot;: &quot;1949a5fb-f7bd-4ada-8ba5-d06d3f5857a8&quot;,
        &quot;mount_options&quot;: null,
        &quot;label&quot;: &quot;&quot;,
        &quot;fstype&quot;: &quot;ext4&quot;,
        &quot;mount_point&quot;: null
    }
    &quot;type&quot;: &quot;partition&quot;,
    &quot;id&quot;: 3,
    &quot;size&quot;: 2000003072
}
</code></pre>
<p><a href="#heading--how-to-list-vmfs-datastores"><h3 id="heading--how-to-list-vmfs-datastores">How to list VMFS datastores</h3></a></p>
<p>To view all VMFS Datastores on a machine, use the &lsquo;vmfs-datastores read&rsquo; API call:</p>
<pre><code class="language-bash">maas $PROFILE vmfs-datastores read $SYSTEM_ID
</code></pre>
<pre><code class="language-nohighlight">[
    {
        &quot;human_size&quot;: &quot;45.8 GB&quot;,
        &quot;filesystem&quot;: {
            &quot;fstype&quot;: &quot;vmfs6&quot;,
            &quot;mount_point&quot;: &quot;/vmfs/volumes/datastore1&quot;
        },
        &quot;uuid&quot;: &quot;2779a745-1db3-4fd7-b06e-455b728fffd4&quot;,
        &quot;name&quot;: &quot;datastore1&quot;,
        &quot;system_id&quot;: &quot;4qxaga&quot;,
        &quot;devices&quot;: [
            {
                &quot;uuid&quot;: &quot;c55fe657-689d-4570-8492-683dd5fa1c40&quot;,
                &quot;size&quot;: 35026632704,
                &quot;bootable&quot;: false,
                &quot;tags&quot;: [],
                &quot;used_for&quot;: &quot;VMFS extent for datastore1&quot;,
                &quot;filesystem&quot;: {
                    &quot;fstype&quot;: &quot;vmfs6&quot;,
                    &quot;label&quot;: null,
                    &quot;uuid&quot;: &quot;55ac6422-68b5-440e-ba65-153032605b51&quot;,
                    &quot;mount_point&quot;: null,
                    &quot;mount_options&quot;: null
                },
                &quot;type&quot;: &quot;partition&quot;,
                &quot;device_id&quot;: 5,
                &quot;path&quot;: &quot;/dev/disk/by-dname/sda-part3&quot;,
                &quot;system_id&quot;: &quot;4qxaga&quot;,
                &quot;id&quot;: 71,
                &quot;resource_uri&quot;: &quot;/MAAS/api/2.0/nodes/4qxaga/blockdevices/5/partition/71&quot;
            },
            {
                &quot;uuid&quot;: &quot;5182e503-4ad4-446e-9660-fd5052b41cc5&quot;,
                &quot;size&quot;: 10729029632,
                &quot;bootable&quot;: false,
                &quot;tags&quot;: [],
                &quot;used_for&quot;: &quot;VMFS extent for datastore1&quot;,
                &quot;filesystem&quot;: {
                    &quot;fstype&quot;: &quot;vmfs6&quot;,
                    &quot;label&quot;: null,
                    &quot;uuid&quot;: &quot;a5949b18-d591-4627-be94-346d0fdaf816&quot;,
                    &quot;mount_point&quot;: null,
                    &quot;mount_options&quot;: null
                },
                &quot;type&quot;: &quot;partition&quot;,
                &quot;device_id&quot;: 6,
                &quot;path&quot;: &quot;/dev/disk/by-dname/sdb-part1&quot;,
                &quot;system_id&quot;: &quot;4qxaga&quot;,
                &quot;id&quot;: 77,
                &quot;resource_uri&quot;: &quot;/MAAS/api/2.0/nodes/4qxaga/blockdevices/6/partition/77&quot;
            }
        ],
        &quot;id&quot;: 17,
        &quot;size&quot;: 45755662336,
        &quot;resource_uri&quot;: &quot;/MAAS/api/2.0/nodes/4qxaga/vmfs-datastore/17/&quot;
    }
]
</code></pre>
<p><a href="#heading--how-to-view-a-vmfs-datastore"><h3 id="heading--how-to-view-a-vmfs-datastore">How to view a VMFS datastore</h3></a></p>
<p>To view a specific VMFS Datastores on a machine, use the &lsquo;vmfs-datastore read&rsquo; API call:</p>
<pre><code class="language-bash">maas $PROFILE vmfs-datastore read $SYSTEM_ID $VMFS_DATASTORE_ID
</code></pre>
<pre><code class="language-nohighlight">{
    &quot;uuid&quot;: &quot;fb6fedc2-f711-40de-ab83-77eddc3e19ac&quot;,
    &quot;name&quot;: &quot;datastore1&quot;,
    &quot;system_id&quot;: &quot;b66fn6&quot;,
    &quot;id&quot;: 18,
    &quot;filesystem&quot;: {
        &quot;fstype&quot;: &quot;vmfs6&quot;,
        &quot;mount_point&quot;: &quot;/vmfs/volumes/datastore1&quot;
    },
    &quot;human_size&quot;: &quot;2.8 GB&quot;,
    &quot;devices&quot;: [
        {
            &quot;uuid&quot;: &quot;b91df576-ba02-4acb-914f-03ba9a2865b7&quot;,
            &quot;size&quot;: 2814377984,
            &quot;bootable&quot;: false,
            &quot;tags&quot;: [],
            &quot;system_id&quot;: &quot;b66fn6&quot;,
            &quot;used_for&quot;: &quot;VMFS extent for datastore1&quot;,
            &quot;type&quot;: &quot;partition&quot;,
            &quot;id&quot;: 80,
            &quot;filesystem&quot;: {
                &quot;fstype&quot;: &quot;vmfs6&quot;,
                &quot;label&quot;: null,
                &quot;uuid&quot;: &quot;4a098d71-1e59-4b5f-932d-fc30a1c0dc96&quot;,
                &quot;mount_point&quot;: null,
                &quot;mount_options&quot;: null
            },
            &quot;device_id&quot;: 1,
            &quot;path&quot;: &quot;/dev/disk/by-dname/vda-part3&quot;,
            &quot;resource_uri&quot;: &quot;/MAAS/api/2.0/nodes/b66fn6/blockdevices/1/partition/80&quot;
        }
    ],
    &quot;size&quot;: 2814377984,
    &quot;resource_uri&quot;: &quot;/MAAS/api/2.0/nodes/b66fn6/vmfs-datastore/18/&quot;
}
</code></pre>
<p><a href="#heading--how-to-create-a-vmfs-datastore"><h3 id="heading--how-to-create-a-vmfs-datastore">How to create a VMFS datastore</h3></a></p>
<p>A VMware VMFS datastore is created on one or more <a href="#heading--about-block-devices">block devices</a> or <a href="#heading--about-partitions">partitions</a>.</p>
<p>To create a VMFS Datastores on a machine use the &lsquo;vmfs-datastores create&rsquo; API call:</p>
<pre><code class="language-bash">maas $PROFILE vmfs-datastores create $SYSTEM_ID name=$VMFS_NAME block_devices=$BLOCK_ID_1,$BLOCK_ID_2 partitions=$PARTITION_ID_1,$PARTITION_ID_2
</code></pre>
<pre><code class="language-nohighlight">{
    &quot;system_id&quot;: &quot;b66fn6&quot;,
    &quot;devices&quot;: [
        {
            &quot;uuid&quot;: &quot;b91df576-ba02-4acb-914f-03ba9a2865b7&quot;,
            &quot;size&quot;: 2814377984,
            &quot;bootable&quot;: false,
            &quot;tags&quot;: [],
            &quot;device_id&quot;: 1,
            &quot;system_id&quot;: &quot;b66fn6&quot;,
            &quot;type&quot;: &quot;partition&quot;,
            &quot;used_for&quot;: &quot;VMFS extent for datastore42&quot;,
            &quot;filesystem&quot;: {
                &quot;fstype&quot;: &quot;vmfs6&quot;,
                &quot;label&quot;: null,
                &quot;uuid&quot;: &quot;fc374367-a2fb-4e50-9377-768bfe9705b6&quot;,
                &quot;mount_point&quot;: null,
                &quot;mount_options&quot;: null
            },
            &quot;path&quot;: &quot;/dev/disk/by-dname/vda-part3&quot;,
            &quot;id&quot;: 80,
            &quot;resource_uri&quot;: &quot;/MAAS/api/2.0/nodes/b66fn6/blockdevices/1/partition/80&quot;
        }
    ],
    &quot;name&quot;: &quot;datastore42&quot;,
    &quot;filesystem&quot;: {
        &quot;fstype&quot;: &quot;vmfs6&quot;,
        &quot;mount_point&quot;: &quot;/vmfs/volumes/datastore42&quot;
    },
    &quot;id&quot;: 19,
    &quot;size&quot;: 2814377984,
    &quot;uuid&quot;: &quot;2711566c-2df4-4cc4-8c06-7392bb1f9532&quot;,
    &quot;human_size&quot;: &quot;2.8 GB&quot;,
    &quot;resource_uri&quot;: &quot;/MAAS/api/2.0/nodes/b66fn6/vmfs-datastore/19/&quot;
}
</code></pre>
<p><a href="#heading--how-to-edit-a-vmfs-datastore"><h2 id="heading--how-to-edit-a-vmfs-datastore">How to edit a VMFS datastore</h2></a></p>
<p>To edit an existing VMFS Datastores on a machine use the &lsquo;vmfs-datastore update&rsquo; API call:</p>
<pre><code class="language-bash">maas $PROFILE vmfs-datastore update $SYSTEM_ID $VMFS_ID name=$NEW_VMFS_NAME add_block_devices=$NEW_BLOCK_ID_1,$NEW_BLOCK_ID_2 add_partitions=$NEW_PARTITION_ID_1,$NEW_PARTITION_ID_2 remove_partitions=$EXISTING_PARTITION_ID1,$EXISTING_PARTITION_ID2
</code></pre>
<pre><code class="language-nohighlight">{
    &quot;uuid&quot;: &quot;2711566c-2df4-4cc4-8c06-7392bb1f9532&quot;,
    &quot;name&quot;: &quot;datastore42&quot;,
    &quot;system_id&quot;: &quot;b66fn6&quot;,
    &quot;id&quot;: 19,
    &quot;filesystem&quot;: {
        &quot;fstype&quot;: &quot;vmfs6&quot;,
        &quot;mount_point&quot;: &quot;/vmfs/volumes/datastore42&quot;
    },
    &quot;human_size&quot;: &quot;13.5 GB&quot;,
    &quot;devices&quot;: [
        {
            &quot;uuid&quot;: &quot;b91df576-ba02-4acb-914f-03ba9a2865b7&quot;,
            &quot;size&quot;: 2814377984,
            &quot;bootable&quot;: false,
            &quot;tags&quot;: [],
            &quot;system_id&quot;: &quot;b66fn6&quot;,
            &quot;used_for&quot;: &quot;VMFS extent for datastore42&quot;,
            &quot;type&quot;: &quot;partition&quot;,
            &quot;id&quot;: 80,
            &quot;filesystem&quot;: {
                &quot;fstype&quot;: &quot;vmfs6&quot;,
                &quot;label&quot;: null,
                &quot;uuid&quot;: &quot;fc374367-a2fb-4e50-9377-768bfe9705b6&quot;,
                &quot;mount_point&quot;: null,
                &quot;mount_options&quot;: null
            },
            &quot;device_id&quot;: 1,
            &quot;path&quot;: &quot;/dev/disk/by-dname/vda-part3&quot;,
            &quot;resource_uri&quot;: &quot;/MAAS/api/2.0/nodes/b66fn6/blockdevices/1/partition/80&quot;
        },
        {
            &quot;uuid&quot;: &quot;f21fe54e-b5b1-4562-ab6b-e699e99f002f&quot;,
            &quot;size&quot;: 10729029632,
            &quot;bootable&quot;: false,
            &quot;tags&quot;: [],
            &quot;system_id&quot;: &quot;b66fn6&quot;,
            &quot;used_for&quot;: &quot;VMFS extent for datastore42&quot;,
            &quot;type&quot;: &quot;partition&quot;,
            &quot;id&quot;: 86,
            &quot;filesystem&quot;: {
                &quot;fstype&quot;: &quot;vmfs6&quot;,
                &quot;label&quot;: null,
                &quot;uuid&quot;: &quot;f3d9b6a3-bab3-4677-becb-bf5a421bfcc2&quot;,
                &quot;mount_point&quot;: null,
                &quot;mount_options&quot;: null
            },
            &quot;device_id&quot;: 2,
            &quot;path&quot;: &quot;/dev/disk/by-dname/vdb-part1&quot;,
            &quot;resource_uri&quot;: &quot;/MAAS/api/2.0/nodes/b66fn6/blockdevices/2/partition/86&quot;
        }
    ],
    &quot;size&quot;: 13543407616,
    &quot;resource_uri&quot;: &quot;/MAAS/api/2.0/nodes/b66fn6/vmfs-datastore/19/&quot;
}
</code></pre>
<p><a href="#heading--how-to-delete-a-vmfs-datastore"><h3 id="heading--how-to-delete-a-vmfs-datastore">How to delete a VMFS datastore</h3  ></a></p>
<p>To delete a VMFS Datastores on a machine use the &lsquo;vmfs-datastore delete&rsquo; API call:</p>
<pre><code class="language-bash">maas $PROFILE vmfs-datastore delete $SYSTEM_ID $VMFS_ID
</code></pre>
<p><a href="#heading--how-to-pre-seed-with-curtin"><h2 id="heading--how-to-pre-seed-with-curtin">How to pre-seed with curtin</h2></a></p>
<p>You can customise the Curtin installation by either editing the existing <code>curtin_userdata</code> template or by adding a custom file as described above.</p>
<p>Curtin provides hooks to execute custom code before and after installation takes place. These hooks are named <code>early</code> and <code>late</code> respectively, and they can both be overridden to execute the Curtin configuration in the ephemeral environment. Additionally, the <code>late</code> hook can be used to execute a configuration for a machine being installed, a state known as in-target.</p>
<p>Curtin commands look like this:</p>
<pre><code>foo: ["command", "--command-arg", "command-arg-value"]
</code></pre>
<p>Each component of the given command makes up an item in an array. Note, however, that the following won&rsquo;t work:</p>
<pre><code>foo: ["sh", "-c", "/bin/echo", "foobar"]
</code></pre>
<p>This syntax won&rsquo;t work because the value of <code>sh</code>&lsquo;s <code>-c</code> argument is itself an entire command. The correct way to express this is:</p>
<pre><code>foo: ["sh", "-c", "/bin/echo foobar"]
</code></pre>
<p>The following is an example of an early command that will run before the installation takes place in the ephemeral environment. The command pings an external machine to signal that the installation is about to start:</p>
<pre><code class="language-bash">early_commands:
  signal: [&quot;wget&quot;, &quot;--no-proxy&quot;, &quot;http://example.com/&quot;, &quot;--post-data&quot;, &quot;system_id=&amp;signal=starting_install&quot;, &quot;-O&quot;, &quot;/dev/null&quot;]
</code></pre>
<p>The following is an example of two late commands that run after installation is complete. Both run in-target, on the machine being installed.</p>
<p>The first command adds a PPA to the machine. The second command creates a file containing the machine’s system ID:</p>
<pre><code class="language-bash">late_commands:
  add_repo: [&quot;curtin&quot;, &quot;in-target&quot;, &quot;--&quot;, &quot;add-apt-repository&quot;, &quot;-y&quot;, &quot;ppa:my/ppa&quot;]
  custom: [&quot;curtin&quot;, &quot;in-target&quot;, &quot;--&quot;, &quot;sh&quot;, &quot;-c&quot;, &quot;/bin/echo -en 'Installed ' &gt; /tmp/maas_system_id&quot;]
</code></pre>
<p><a href="#heading--cloud-init"><h2 id="heading--cloud-init">How to pre-seed with cloud-init</h2></a></p>
<p>Using cloud-init to customise a machine after deployment is relatively easy. After you&rsquo;re logged in, use the following command to deploy a machine with a custom script you&rsquo;ve written:</p>
<pre><code>maas $PROFILE machine deploy $SYSTEM_ID user_data=&lt;base-64-encoded-script&gt;
</code></pre>
<p>The three replaceable parameters shown above decode to:</p>
<ol>
<li><code>$PROFILE</code>: Your MAAS login. E.g. <code>admin</code></li>
<li><code>$SYSTEM_ID</code>: The machine&rsquo;s system ID (see example below)</li>
<li><code>&lt;base-64-encoded-script&gt;</code>: A base-64 encoded copy of your customisation script. See below for an example.</li>
</ol>
<p>E.g.:</p>
<p>Suppose you would like to import an SSH key immediately after your machine deployment. First, you want to find the machine&rsquo;s <code>system_id</code>, which you can do with this short, command-line <code>jq</code> script:</p>
<pre><code>maas admin machines read | jq -r '([&quot;HOSTNAME&quot;,&quot;SYSID&quot;] | (., map(length*&quot;-&quot;))),
(.[] | [.hostname, .system_id]) | @tsv' | column -t
</code></pre>
<p>You might then use this script, called <code>import_key.sh</code>, to retrieve the needed key:</p>
<pre><code class="language-bash">#!/bin/bash
(
echo === $date ===
ssh-import-id foobar_user
) | tee /ssh-key-import.log
</code></pre>
<p>This script echos the date in addition to the output of the <code>ssh-import-key</code> command. It also adds that output to a file, <code>/ssh-key-import.log</code>.</p>
<p>Base-64 encoding is required because the MAAS command-line interacts with the MAAS API, and base-64 encoding allows MAAS to send the script inside a POST HTTP command.</p>
<p>Use the <code>base64</code> command to output a base-64 encoded version of your script:</p>
<pre><code>base64 -w0 ./import_key.sh
</code></pre>
<p>Putting it together:</p>
<pre><code>maas $PROFILE machine deploy $SYSTEM_ID user_data=$(base64 -w0 ./import_key.sh)
</code></pre>
<p>After MAAS deploys the machine, you&rsquo;ll find <code>/ssh-key-import.log</code> on the machine you deployed.</p>
<p><a href="#heading--how-to-choose-ubuntu-kernels"><h2 id="heading--how-to-choose-ubuntu-kernels">How to choose Ubuntu kernels</h2></a></p>
<p>This section will show you:</p>
<ul>
<li><a href="#heading--set-a-default-minimum-kernel-for-enlistment-and-commissioning">How to set a default minimum kernel for enlistment and commissioning</a></li>
<li><a href="#heading--set-a-minimum-deploy-kernel-for-a-machine">How to set a minimum deployment kernel for a machine</a></li>
<li><a href="#heading--set-a-specific-kernel-during-machine-deployment">How to set a specific kernel during machine deployment</a></li>
</ul>
<p><a href="#heading--set-a-default-minimum-kernel-for-enlistment-and-commissioning"><h3 id="heading--set-a-default-minimum-kernel-for-enlistment-and-commissioning">How to set a default minimum kernel for enlistment and commissioning</h3></a></p>
<p>To set a default minimum kernel for all new and commissioned machines:</p>
<pre><code class="language-bash">maas $PROFILE maas set-config name=default_min_hwe_kernel value=$KERNEL
</code></pre>
<p>For example, to set it to the 16.04 GA kernel:</p>
<pre><code class="language-bash">maas $PROFILE maas set-config name=default_min_hwe_kernel value=ga-16.04
</code></pre>
<p>[note]
The command option <code>default_min_hwe_kernel</code> appears to apply to only HWE kernels but this is not the case.
[/note]</p>
<p><a href="#heading--set-a-minimum-deploy-kernel-for-a-machine"><h3 id="heading--set-a-minimum-deploy-kernel-for-a-machine">How to set a minimum deployment kernel for a machine</h3></a></p>
<p>To set the minimum deploy kernel on a per-machine basis:</p>
<pre><code class="language-bash">maas $PROFILE machine update $SYSTEM_ID min_hwe_kernel=$HWE_KERNEL
</code></pre>
<p>For example, to set it to the HWE 16.04 kernel:</p>
<pre><code class="language-bash">maas $PROFILE machine update $SYSTEM_ID min_hwe_kernel=hwe-16.04
</code></pre>
<p>[note]
The command option <code>default_min_hwe_kernel</code> appears to apply to only HWE kernels but this is not the case.
[/note]</p>
<p><a href="#heading--set-a-specific-kernel-during-machine-deployment"><h3 id="heading--set-a-specific-kernel-during-machine-deployment">How to set a specific kernel during machine deployment</h3></a></p>
<p>To set a specific kernel during the deployment of a machine:</p>
<pre><code class="language-bash">maas $PROFILE machine deploy $SYSTEM_ID distro_series=$SERIES hwe_kernel=$KERNEL
</code></pre>
<p>The operation will fail if the kernel specified by <code>hwe_kernel</code> is older than the kernel (possibly) given by <code>default_min_hwe_kernel</code>. Similarly, it will not work if the kernel is not available for the given distro series (such as &lsquo;hwe-16.10&rsquo; for &lsquo;xenial&rsquo;).</p>
<p>For example, to deploy a Xenial node with the HWE 16.04 edge kernel:</p>
<pre><code class="language-bash">maas $PROFILE machine deploy $SYSTEM_ID distro_series=xenial hwe_kernel=hwe-16.04-edge
</code></pre>
<p>[note]
The command option <code>hwe_kernel</code> appears to apply to only HWE kernels but this is not the case.
[/note]</p>
<p><a href="#heading--how-to-set-global-kernel-boot-options"><h2 id="heading--how-to-set-global-kernel-boot-options">How to set global kernel boot options</h2></a></p>
<p>You can set kernel boot options and apply them to all machines with the CLI command:</p>
<pre><code class="language-bash">maas $PROFILE maas set-config name=kernel_opts value='$KERNEL_OPTIONS'
</code></pre>
<p>See <a href="how-to-manage-tags-5183.html">How can I set kernel boot options for a specific machine?</a> to set per-machine kernel boot options.</p>
<p><a href="#heading--how-to-use-resource-pools"><h2 id="heading--how-to-use-resource-pools">How to use resource pools</h2></a></p>
<p>This section will explain:</p>
<ul>
<li><a href="#heading--creating-a-resource-pool">How to create a resource pool</a></li>
<li><a href="#heading--list-available-resource-pools">How to list available resource pools</a></li>
<li><a href="#heading--list-a-single-resource-pool">How to list a single resource pool</a></li>
<li><a href="#heading--update-a-resource-pool">How to update a resource pool</a></li>
<li><a href="#heading--delete-a-resource-pool">How to delete a resource pool</a></li>
<li><a href="#heading--add-a-machine-to-a-resource-pool">How to add a machine to a resource pool</a></li>
</ul>
<p><a href="#heading--creating-a-resource-pool"><h3 id="heading--creating-a-resource-pool">How to create a resource pool</h3></a></p>
<p>Here&rsquo;s an example that demonstrates how to create a new resource pool named <code>myresource</code>.</p>
<pre><code class="language-bash">maas $PROFILE resource-pools create name=myresource description=&quot;A new resource pool.&quot;
</code></pre>
<p>[note]
The <code>description</code> field is optional.
[/note]</p>
<p><a href="#heading--list-available-resource-pools"><h3 id="heading--list-available-resource-pools">How to list available resource pools</h3></a></p>
<pre><code class="language-bash">maas $PROFILE resource-pools read
</code></pre>
<p><a href="#heading--list-a-single-resource-pool"><h3 id="heading--list-a-single-resource-pool">How to list a single resource pool</h3></a></p>
<pre><code class="language-bash">maas $PROFILE resource-pool read $RESOURCE_POOL_ID
</code></pre>
<p><a href="#heading--update-a-resource-pool"><h3 id="heading--update-a-resource-pool">How to update a resource pool</h3></a></p>
<pre><code class="language-bash">maas $PROFILE resource-pool update $RESOURCE_POOL_ID name=newname description=&quot;A new description.&quot;
</code></pre>
<p>[note]
The <code>name</code> and <code>description</code> fields are optional.
[/note]</p>
<p><a href="#heading--delete-a-resource-pool"><h3 id="heading--delete-a-resource-pool">How to delete a resource pool</h3></a></p>
<pre><code class="language-bash">maas $PROFILE resource-pool delete $RESOURCE_POOL_ID
</code></pre>
<p><a href="#heading--add-a-machine-to-a-resource-pool"><h3 id="heading--add-a-machine-to-a-resource-pool">How to add a machine to a resource pool</h3></a></p>
<pre><code class="language-bash">maas $PROFILE machine update $SYSTEM_ID pool=$POOL_NAME
</code></pre>
<p><a href="#heading--storage-layouts-reference"><h2 id="heading--storage-layouts-reference">Storage layouts reference</h2></a></p>
<p>There are three layout types:</p>
<ol>
<li>Flat layout</li>
<li>LVM layout</li>
<li>bcache layout</li>
</ol>
<p>The layout descriptions below will include the EFI partition. If your system is not using UEFI, regard <code>sda2</code> as <code>sda1</code> (with an additional 512 MB available to it).</p>
<p><a href="#heading--flat-storage-layout-reference"><h3 id="heading--flat-storage-layout-reference">Flat layout storage reference</h3></a></p>
<p>With the Flat layout, a partition spans the entire boot disk. The partition is formatted with the ext4 filesystem and uses the <code>/</code> mount point:</p>
<table>
<thead>
<tr>
<th align="center">Name</th>
<th align="right">Size</th>
<th align="center">Type</th>
<th align="center">Filesystem</th>
<th align="left">Mount point</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">sda</td>
<td align="right">-</td>
<td align="center">disk</td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">sda1</td>
<td align="right">512 MB</td>
<td align="center">part</td>
<td align="center">FAT32</td>
<td align="left">/boot/efi</td>
</tr>
<tr>
<td align="center">sda2</td>
<td align="right">rest of sda</td>
<td align="center">part</td>
<td align="center">ext4</td>
<td align="left">/</td>
</tr>
</tbody>
</table>
<p>The following three options are supported:</p>
<ol>
<li>
<p><code>boot_size</code>: Size of the boot partition on the boot disk. Default is 0, meaning not to create the boot partition. The &lsquo;/boot&rsquo; will be placed on the root filesystem.</p>
</li>
<li>
<p><code>root_device</code>: The block device on which to place the root partition. The default is the boot disk.</p>
</li>
<li>
<p><code>root_size</code>: Size of the root partition. Default is 100%, meaning the entire size of the root device.</p>
</li>
</ol>
<p><a href="#heading--lvm-storage-layout-reference"><h3 id="heading--lvm-storage-layout-reference">LVM storage layout reference</h3></a></p>
<p>The LVM layout creates the volume group <code>vgroot</code> on a partition that spans the entire boot disk. A logical volume <code>lvroot</code> is created for the full size of the volume group; is formatted with the ext4 filesystem; and uses the <code>/</code> mount point:</p>
<table>
<thead>
<tr>
<th align="center">Name</th>
<th align="right">Size</th>
<th align="center">Type</th>
<th align="center">Filesystem</th>
<th align="left">Mount point</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">sda</td>
<td align="right">-</td>
<td align="center">disk</td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">sda1</td>
<td align="right">512 MB</td>
<td align="center">part</td>
<td align="center">FAT32</td>
<td align="left">/boot/efi</td>
</tr>
<tr>
<td align="center">sda2</td>
<td align="right">rest of sda</td>
<td align="center">part</td>
<td align="center">lvm-pv(vgroot)</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">lvroot</td>
<td align="right">rest of sda</td>
<td align="center">lvm</td>
<td align="center">ext4</td>
<td align="left">/</td>
</tr>
<tr>
<td align="center">vgroot</td>
<td align="right">rest of sda</td>
<td align="center">lvm</td>
<td align="center"></td>
<td align="left"></td>
</tr>
</tbody>
</table>
<p>The following six options are supported:</p>
<ol>
<li><code>boot_size</code>: Size of the boot partition on the boot disk. Default is 0, meaning not to create the boot partition. The &lsquo;/boot&rsquo; will be placed on the root filesystem.</li>
<li><code>root_device</code>: The block device on which to place the root partition. The default is the boot disk.</li>
<li><code>root_size</code>: Size of the root partition. Default is 100%, meaning the entire size of the root device.</li>
<li><code>vg_name</code>: Name of the created volume group. Default is <code>vgroot</code>.</li>
<li><code>lv_name</code>: Name of the created logical volume. Default is <code>lvroot</code>.</li>
<li><code>lv_size</code>: Size of the created logical volume. Default is 100%, meaning the entire size of the volume group.</li>
</ol>
<p><a href="#heading--bcache-storage-layout-reference"><h3 id="heading--bcache-storage-layout-reference">bcache storage layout reference</h3></a></p>
<p>A bcache layout will create a partition that spans the entire boot disk as the backing device. It uses the smallest block device tagged with &lsquo;ssd&rsquo; as the cache device. The bcache device is formatted with the ext4 filesystem and uses the <code>/</code> mount point. If there are no &lsquo;ssd&rsquo; tagged block devices on the machine, then the bcache device will not be created, and the Flat layout will be used instead:</p>
<table>
<thead>
<tr>
<th align="center">Name</th>
<th align="right">Size</th>
<th align="center">Type</th>
<th align="center">Filesystem</th>
<th align="left">Mount point</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">sda</td>
<td align="right">-</td>
<td align="center">disk</td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">sda1</td>
<td align="right">512 MB</td>
<td align="center">part</td>
<td align="center">FAT32</td>
<td align="left">/boot/efi</td>
</tr>
<tr>
<td align="center">sda2</td>
<td align="right">rest of sda</td>
<td align="center">part</td>
<td align="center">bc-backing</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">sdb (ssd)</td>
<td align="right">-</td>
<td align="center">disk</td>
<td align="center"></td>
<td align="left"></td>
</tr>
<tr>
<td align="center">sdb1</td>
<td align="right">100% of sdb</td>
<td align="center">part</td>
<td align="center">bc-cache</td>
<td align="left"></td>
</tr>
<tr>
<td align="center">bcache0</td>
<td align="right">per sda2</td>
<td align="center">disk</td>
<td align="center">ext4</td>
<td align="left">/</td>
</tr>
</tbody>
</table>
<p>The following seven options are supported:</p>
<ol>
<li><code>boot_size</code>: Size of the boot partition on the boot disk. Default is 0, meaning not to create the boot partition. The &lsquo;/boot&rsquo; will be placed on the root filesystem.</li>
<li><code>root_device</code>: The block device upon which to place the root partition. The default is the boot disk.</li>
<li><code>root_size</code>: Size of the root partition. Default is 100%, meaning the entire size of the root device.</li>
<li><code>cache_device</code>: The block device to use as the cache device. Default is the smallest block device tagged ssd.</li>
<li><code>cache_mode</code>: The cache mode to which MAAS should set the created bcache device. The default is <code>writethrough</code>.</li>
<li><code>cache_size</code>: The size of the partition on the cache device. Default is 100%, meaning the entire size of the cache device.</li>
<li><code>cache_no_part</code>: Whether or not to create a partition on the cache device. Default is false, meaning to create a partition using the given <code>cache_size</code>. If set to true, no partition will be created, and the raw cache device will be used as the cache.</li>
</ol>
<p><a href="#heading--vmfs6-storage-layout-reference"><h3 id="heading--vmfs6-storage-layout-reference">VMFS6 storage layout reference</h3></a></p>
<p>The VMFS6 layout is used for VMware ESXi deployments only. It is required when configuring VMware VMFS Datastores. This layout creates all operating system partitions, in addition to the default datastore. The datastore may be modified.  New datastores may be created or extended to include other storage devices. The base operating system partitions may not be modified because VMware ESXi requires them. Once applied another storage layout must be applied to remove the operating system partitions.</p>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="right">Size</th>
<th align="center">Type</th>
<th align="left">Use</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">sda</td>
<td align="right">-</td>
<td align="center">disk</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">sda1</td>
<td align="right">3 MB</td>
<td align="center">part</td>
<td align="left">EFI</td>
</tr>
<tr>
<td align="left">sda2</td>
<td align="right">4 GB</td>
<td align="center">part</td>
<td align="left">Basic Data</td>
</tr>
<tr>
<td align="left">sda3</td>
<td align="right">Remaining</td>
<td align="center">part</td>
<td align="left">VMFS Datastore 1</td>
</tr>
<tr>
<td align="left">sda4</td>
<td align="right">-</td>
<td align="center">skipped</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">sda5</td>
<td align="right">249 MB</td>
<td align="center">part</td>
<td align="left">Basic Data</td>
</tr>
<tr>
<td align="left">sda6</td>
<td align="right">249 MB</td>
<td align="center">part</td>
<td align="left">Basic Data</td>
</tr>
<tr>
<td align="left">sda7</td>
<td align="right">109 MB</td>
<td align="center">part</td>
<td align="left">VMware Diagnostic</td>
</tr>
<tr>
<td align="left">sda8</td>
<td align="right">285 MB</td>
<td align="center">part</td>
<td align="left">Basic Data</td>
</tr>
<tr>
<td align="left">sda9</td>
<td align="right">2.5 GB</td>
<td align="center">part</td>
<td align="left">VMware Diagnostic</td>
</tr>
</tbody>
</table>
<p>The following options are supported:</p>
<ol>
<li>
<p><code>root_device</code>: The block device upon which to place the root partition. Default is the boot disk.</p>
</li>
<li>
<p><code>root_size</code>: Size of the default VMFS Datastore. Default is 100%, meaning the remaining size of the root disk.</p>
</li>
</ol>
<p><a href="#heading--blank-storage-layout-reference"><h3 id="heading--blank-storage-layout-reference">Blank storage layout reference</h3></a></p>
<p>The blank layout removes all storage configuration from all storage devices. It is useful when needing to apply a custom storage configuration.</p>
<p>[note type=&rdquo;negative&rdquo; status=&rdquo;Warning&rdquo;]
Machines with the blank layout applied are not deployable; you must first configure storage manually.
[/note]</p>
    </div>
  </body>
</html>