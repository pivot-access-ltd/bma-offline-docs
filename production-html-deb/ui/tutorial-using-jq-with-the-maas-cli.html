<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="css/stylesheet.css" />
    <style>
      #selector a:link{color:black;}
      #selector a:visited{color:black;}
      #selector a:active{color:black;}
      #selector a:hover{color:blue;}
      #sidebar a:link{color:black;}
      #sidebar a:visited{color:black;}
      #sidebar a:active{color:black;}
      #sidebar a:hover{color:blue;}
      ul {margin-left:0;list-style-type:none;}
      li {margin: 4px 0;}
    </style>
  </head>
  <body>
    <div id="selector" style="top:0; position:fixed; float:right; background-color:#d9d9d9; width:100%;border-bottom:1px solid black;">
      &nbsp;&nbsp;
      <strong>Offline docs
      </strong>
      <a href="https://maas.io/docs">(switch to live docs)
      </a>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      <span style="background-color:white;border-top:1px solid black; border-left:1px solid black; border-right:1px solid black; border-bottom:5px solid white;">
	  UI-only
      </span>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<a href="../cli/tutorial-using-jq-with-the-maas-cli.html">
	  CLI-only
	</a>
    </div>
    <div id="sidebar" style="float:left; width:25%;margin-top:40px; margin-left:20px">
      <strong>
	<a href="maas-documentation-25.html">
	  Home
	</a>
      </strong> 
      <strong>
	<a href="tutorials.html">
	  Tutorials
	</a>
      </strong>
      <ul>
	<li>
	  <a href="bootstrap-maas.html">
	    Bootstrap MAAS
	  </a>
	</li>
	<li>
	  <a href="try-out-the-maas-cli.html">
	    Try out the MAAS CLI
	  </a>
	</li>
	<li>
	  <a href="create-a-custom-image.html">
	    Create a custom image
	  </a>
	</li>
	<li>
	  <a href="get-fancy-cli-output.html">
	    Get fancy CLI output
	  </a>
	</li>
      </ul>
      <strong>
	<a href="how-to-get-started-with-maas.html">
	  How to get started with MAAS
	</a>
      </strong>
      <ul>
	<li>
	  <a href="how-to-do-a-fresh-install-of-maas.html">
	    Do a fresh install of MAAS
	  </a>
	</li>
	<li>
	  <a href="how-to-upgrade-maas.html">
	    Upgrade MAAS
	  </a>
	</li>
	<li>
	  <a href="how-to-spin-up-maas-with-ansible.html">
	    Spin up MAAS with Ansible
	  </a>
	</li>
      </ul>
      <strong>
	<a href="how-to-set-up-networks.html">
	  How to set up networks
	</a>
      </strong>
      <ul>
	<li>
	  <a href="how-to-connect-maas-networks.html">
	    Connect MAAS networks
	  </a>
	</li>
	<li>
	  <a href="how-to-enable-dhcp.html">
	    Enable DHCP
	  </a>
	</li>
	<li>
	  <a href="how-to-use-availability-zones.html">
	    Use availability zones
	  </a>
	</li>
      </ul>
      <strong>
	<a href="how-to-use-images.html">
	  How to use images
	</a>
      </strong>
      <ul>
	<li>
	  <a href="how-use-standard-images.html">
	    Use standard images
	  </a>
	</li>
	<li>
	  <a href="how-to-mirror-images-locally.html">
	    Mirror images locally
	  </a>
	</li>
	<li>
	  <a href="how-to-customise-images.html">
	    Customise images
	  </a>
	</li>
	<li>
	  <a href="how-to-employ-vmware-images.html">
	    Employ VMWare images
	  </a>
	</li>
	<li>
	  <a href="how-to-deploy-a-rt-kernel-via-cloud-init.html">
	    Deploy a RT kernel
	  </a>
	</li>
      </ul>
      <strong>
	<a href="how-to-manage-controllers.html">
	  How to manage controllers
	</a>
      </strong>
      <ul>
	<li>
	  <a href="how-to-configure-controllers.html">
	    Configure controllers
	  </a>
	</li>
	<li>
	  <a href="how-to-enable-high-availability.html">
	    Enable HA
	  </a>
	</li>
      </ul>
      <strong>
	<a href="how-to-manage-machines.html">
	  How to manage machines
	</a>
      </strong>
      <ul>
	<li>
	  <a href="how-to-make-machines-available.html">
	    Make machines available
	  </a>
	</li>
	<li>
	  <a href="how-to-customise-machines.html">
	    Customise machines
	  </a>
	</li>
	<li>
	  <a href="how-to-put-machines-to-work.html">
	    Put machines to work
	  </a>
	</li>
      </ul>
      <strong>
	<a href="how-to-use-virtual-machines.html">
	  How to use virtual machines
	</a>
      </strong>
      <ul>
	<li>
	  <a href="how-to-set-up-lxd.html">
	    Set up LXD
	  </a>
	</li>
	<li>
	  <a href="how-to-manage-vm-hosts.html">
	    Manage VM hosts
	  </a>
	</li>
	<li>
	  <a href="how-to-manage-virtual-machines.html">
	    Manage virtual machines
	  </a>
	</li>
      </ul>
      <strong>
	<a href="how-to-label-devices.html">
	  How to label devices
	</a>
      </strong>
      <ul>
	<li>
	  <a href="how-to-tag-machines.html">
	    Tag machines
	  </a>
	</li>
	<li>
	  <a href="how-to-annotate-machines.html">
	    Annotate machines
	  </a>
	</li>
	<li>
	  <a href="how-to-use-machine-tags.html">
	    Use machine tags
	  </a>
	</li>
	<li>
	  <a href="how-to-use-controller-tags.html">
	    Use controller tags
	  </a>
	</li>
	<li>
	  <a href="how-to-use-storage-tags.html">
	    Use storage tags
	  </a>
	</li>
	<li>
	  <a href="how-to-use-network-tags.html">
	    Use network tags
	  </a>
	</li>
      </ul>
      <strong>
	<a href="how-to-secure-maas.html">
	  How to secure MAAS
	</a>
      </strong>
      <ul>
	<li>
	  <a href="how-to-improve-maas-security.html">
	    Improve MAAS security
	  </a>
	</li>
	<li>
	  <a href="how-to-manage-user-accounts.html">
	    Manage user accounts
	  </a>
	</li>
	<li>
	  <a href="how-to-enable-maas-native-tls.html">
	    Enable MAAS native TLS
	  </a>
	</li>
	<li>
	  <a href="how-to-use-hashicorp-vault-with-maas.html">
	    Use Vault with MAAS
	  </a>
	</li>
	<li>
	  <a href="how-to-set-up-an-air-gapped-maas.html">
	    Set up an air-gapped MAAS
	  </a>
	</li>
      </ul>
      <strong>
	<a href="how-to-operate-maas.html">
	  How to operate MAAS
	</a>
      </strong>
      <ul>
	<li>
	  <a href="how-to-find-machines.html">
	    Find machines
	  </a>
	</li>
	<li>
	  <a href="how-to-back-up-maas.html">
	    Back up MAAS
	  </a>
	</li>
	<li>
	  <a href="how-to-monitor-maas.html">
	    Monitor MAAS
	  </a>
	</li>
	<li>
	  <a href="how-to-audit-maas.html">
	    Audit MAAS
	  </a>
	</li>
	<li>
	  <a href="how-to-troubleshoot-maas.html">
	    Troubleshoot MAAS
	  </a>
	</li>
      </ul>
      <strong>
	<a href="how-to-give-and-receive-help.html">
	  How to give and receive help
	</a>
      </strong>
      <ul>
	<li>
	  <a href="how-to-use-our-discourse-forum.html">
	    Use our discourse forum
	  </a>
	</li>
	<li>
	  <a href="how-to-contact-us">
	    Get support↗
	  </a>
	</li>
	<li>
	  <a href="how-to-request-new-features.html">
	    Request new features
	  </a>
	</li>
	<li>
	  <a href="how-to-review-and-report-bugs.html">
	    Review and report bugs
	  </a>
	</li>
	<li>
	  <a href="how-to-contribute-doc.html">
	    Contribute documentation
	  </a>
	</li>
      </ul>
      <strong>
	<a href="general-reference.html">
	  General reference
	</a>
      </strong>
      <ul>
	<li>
	  <a href="what-is-new-with-maas.html">
	    Release notes
	  </a>
	</li>
	<li>
	  <a href="maas-installation-requirements.html">
	    Installation requirements
	  </a>
	</li>
	<li>
	  <a href="maas-settings-reference.html">
	    MAAS settings
	  </a>
	</li>
	<li>
	  <a href="https://launchpad.net/maas.html">
	    MAAS source code↗
	  </a>
	</li>
	<li>
	  <a href="how-to-help-improve-the-doc.html">
	    Doc style guide
	  </a>
	</li>
	<li>
	  <a href="maas-glossary.html">
	    Glossary
	  </a>
	</li>
	<li>
	  <a href="https://ubuntu.com/community/code-of-conduct">
	    Code of conduct↗
	  </a>
	</li>
      </ul>
      <strong>
	<a href="api-reference.html">
	  API reference
	</a>
      </strong>
      <ul>
	<li>
	  <a href="api-authentication-reference.html">
	    API authentication
	  </a>
	</li>
	<li>
	  <a href="python-api-client-reference.html">
	    Python API client
	  </a>
	</li>
	<li>
	  <a href="api">
	    API documentation↗
	  </a>
	</li>
      </ul>
      <strong>
	<a href="maas-scripts-reference.html">
	  Scripts reference
	</a>
      </strong>
      <ul>
	<li>
	  <a href="commissioning-scripts-reference.html">
	    Commissioning scripts
	  </a>
	</li>
	<li>
	  <a href="hardware-test-scripts-reference.html">
	    Hardware test scripts
	  </a>
	</li>
	<li>
	  <a href="maas-terraform-reference.html">
	    Terraform
	  </a>
	</li>
      </ul>
      <strong>
	<a href="maas-logs-reference.html">
	  Log reference
	</a>
      </strong>
      <ul>
	<li>
	  <a href="event-logs-reference.html">
	    Event logs
	  </a>
	</li>
	<li>
	  <a href="audit-event-logs-reference.html">
	    Audit event logs
	  </a>
	</li>
	<li>
	  <a href="commissioning-logs-reference.html">
	    Commissioning logs
	  </a>
	</li>
	<li>
	  <a href="testing-logs-reference.html">
	    Testing logs
	  </a>
	</li>
      </ul>
      <strong>
	<a href="machine-parameters-reference.html">
	  Machine parameters reference
	</a>
      </strong>
      <ul>
	<li>
	  <a href="power-drivers-reference.html">
	    Power drivers
	  </a>
	</li>
	<li>
	  <a href="storage-layouts-reference.html">
	    Storage layouts
	  </a>
	</li>
	<li>
	  <a href="device-labelling-reference.html">
	    Device labelling
	  </a>
	</li>
      </ul>
      <strong>
	<a href=".html">
	  Explanation
	</a>
      </strong>
      <ul>
	<li>
	  <a href="about-maas.html">
	    About MAAS
	  </a>
	</li>
	<li>
	  <a href="about-networking.html">
	    About networking
	  </a>
	</li>
	<li>
	  <a href="about-images.html">
	    About images
	  </a>
	</li>
	<li>
	  <a href="about-controllers.html">
	    About controllers
	  </a>
	</li>
	<li>
	  <a href="about-machines.html">
	    About machines
	  </a>
	</li>
	<li>
	  <a href="about-virtual-machines.html">
	    About virtual machines
	  </a>
	</li>
	<li>
	  <a href="about-device-labels.html">
	    About device labels
	  </a>
	</li>
	<li>
	  <a href="about-maas-events.html">
	    About MAAS events
	  </a>
	</li>
	<li>
	  <a href="about-maas-audit-events.html">
	    About audit events
	  </a>
	</li>
	<li>
	  <a href="about-maas-logging.html">
	    About MAAS logging
	  </a>
	</li>
	<li>
	  <a href="about-maas-security.html">
	    About MAAS security
	  </a>
	</li>
	<li>
	  <a href="about-maas-performance.html">
	    About MAAS performance
	  </a>
	</li>
	<li>
	  <a href="about-ansible.html">
	    About Ansible
	  </a>
	</li>
      </ul>
    </div>
    <div class="container" style="float:right; width:65%; margin-top:40px; margin-right:30px">
      <h1>Using jq with the MAAS CLI</h1><!-- "Using jq with the MAAS CLI" -->
<p>The JSON output from the MAAS CLI can be very lengthy for even one machine. You can imagine how large a listing 10 or 12 or 600 machines might present. Traditional JSON output is both consistent and comprehensive, but it&rsquo;s sometimes hard for humans to process.</p>
<p>Enter <code>jq</code>, a command-line tool dedicated to filtering and formatting JSON output, so that you can more easily summarise data. For instance, consider a small MAAS install with 12 virtual machines. Six of these machines are LXD VMs, and six are libvirt VMs. Suppose we enter the MAAS command to list all those machines:</p>
<pre><code class="language-nohighlight">maas admin machines read
</code></pre>
<p>The listing would be many pages long, and likely very time-consuming to pick through, so we&rsquo;ll just skip it here. On the other hand, I can apply the jq command, a couple of other Ubuntu CLI commands, and just a little bit of finesse to get something more useful:</p>
<pre><code class="language-nohighlight">maas admin machines read | jq -r '([&quot;HOSTNAME&quot;,&quot;SYSID&quot;,
&quot;POWER&quot;,&quot;STATUS&quot;,&quot;OWNER&quot;, &quot;TAGS&quot;, &quot;POOL&quot;,&quot;VLAN&quot;,&quot;FABRIC&quot;,
&quot;SUBNET&quot;] | (., map(length*&quot;-&quot;))),(.[] | [.hostname, .system_id, 
.power_state, .status_name, .owner // &quot;-&quot;,.tag_names[0] // &quot;-&quot;, 
.pool.name,.boot_interface.vlan.name,.boot_interface.vlan.fabric,
.boot_interface.links[0].subnet.name]) | @tsv' | column -t
</code></pre>
<p>In fact, with this command, we can produce an useful and compact machine listing that serves about 99% of our routine MAAS information needs:</p>
<pre><code class="language-nohighlight">HOSTNAME      SYSID   POWER  STATUS     OWNER  TAGS                 POOL     VLAN      FABRIC    SUBNET
 --------      -----   -----  ------     -----  ----                 ----     ----      ------    ------
 lxd-vm-1      r8d6yp  off    Deployed   admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
 lxd-vm-2      tfftrx  off    Allocated  admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
 lxd-vm-3      grwpwc  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
 lxd-vm-4      6s8dt4  off    Deployed   admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
 lxd-vm-5      pyebgm  off    Allocated  admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
 lxd-vm-6      ebnww6  off    New        -      pod-console-logging  default  untagged  fabric-1  
 libvirt-vm-1  m7ffsg  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
 libvirt-vm-2  kpawad  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
 libvirt-vm-3  r44hr6  error  Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
 libvirt-vm-4  s3sdkw  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
 libvirt-vm-5  48dg8m  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
 libvirt-vm-6  bacx77  on     Deployed   admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
</code></pre>
<p>Here we have a clean text table listing the machine hostnames, along with the system IDs, power states, machines statuses, tags, pools, and networking information. These parameters represent only a small fraction of the available JSON output, of course. Let&rsquo;s break this command down, piece by piece, and see how it works.</p>
<p><a href="#heading--Basic-jq-usage"><h2 id="heading--Basic-jq-usage">Basic jq usage</h2></a></p>
<p>First, we&rsquo;ll just pull the hostnames from these machines, with no qualifiers or formatting rules, like this:</p>
<pre><code class="language-nohighlight">maas admin machines read | jq '(.[] | [.hostname])'
</code></pre>
<p>This command returns output that looks something like this:</p>
<pre><code class="language-nohighlight">[
  &quot;lxd-vm-1&quot;
]
[
  &quot;lxd-vm-2&quot;
]
[
  &quot;lxd-vm-3&quot;
]
[
  &quot;lxd-vm-4&quot;
]
[
  &quot;lxd-vm-5&quot;
]
[
  &quot;lxd-vm-6&quot;
]
[
  &quot;libvirt-vm-1&quot;
]
[
  &quot;libvirt-vm-2&quot;
]
[
  &quot;libvirt-vm-3&quot;
]
[
  &quot;libvirt-vm-4&quot;
]
[
  &quot;libvirt-vm-5&quot;
]
[
  &quot;libvirt-vm-6&quot;
]
</code></pre>
<p>Note a couple of things about this command:</p>
<pre><code class="language-nohighlight">maas admin machines read | jq '(.[] | [.hostname])'
</code></pre>
<p>First, the <code>jq</code> instructions are enclosed in single quotes. As such, they can span lines if necessary, without any line continuations (), like this:</p>
<pre><code class="language-nohighlight">maas admin machines read | jq '(.[]
| [.hostname])'
</code></pre>
<p>Second, notice the structure of the jq instructions. The .[] tells jq that it&rsquo;s decoding an array of data sets — in this case, an array of machine data sets — and that it should iterate through each of the outer data sets (each machine) individually. The pipe symbol (|) completes the “for each” construct, so this command basically says, “for each set of machine data you get, pull out (and return) the value associated with the JSON key hostname&rdquo;. The return value reflects this structure:</p>
<pre><code class="language-nohighlight">
[
   &quot;libvirt-vm-5&quot;
]
[
   &quot;libvirt-vm-6&quot;
]
</code></pre>
<p>The outer square brackets represent the boundaries of each machine&rsquo;s data set, and the value in quotes corresponds to the value of the key hostname in successive machine data sets. It can get a little complicated sometimes, but that&rsquo;s basically the way to parse JSON with jq.</p>
<p>For practice let&rsquo;s try pulling the value of the key that holds machine status, again with no qualifiers or special formatting:</p>
<pre><code class="language-nohighlight">maas admin machines read | jq '(.[] | [.hostname, .status_name])'
</code></pre>
<p>This command essentially tells jq to do the same thing as last time, but also collect the value of the key “status_name” for each machine. The results looks something like this:</p>
<pre><code class="language-nohighlight">
[
  &quot;lxd-vm-1&quot;,
  &quot;Deployed&quot;
]
[
  &quot;lxd-vm-2&quot;,
  &quot;Allocated&quot;
]
[
  &quot;lxd-vm-3&quot;,
  &quot;Ready&quot;
]
[
  &quot;lxd-vm-4&quot;,
  &quot;Deployed&quot;
]
[
  &quot;lxd-vm-5&quot;,
  &quot;Allocated&quot;
]
[
  &quot;lxd-vm-6&quot;,
  &quot;New&quot;
]
[
  &quot;libvirt-vm-1&quot;,
  &quot;Ready&quot;
]
[
  &quot;libvirt-vm-2&quot;,
  &quot;Ready&quot;
]
[
  &quot;libvirt-vm-3&quot;,
  &quot;Ready&quot;
]
[
  &quot;libvirt-vm-4&quot;,
  &quot;Ready&quot;
]
[
  &quot;libvirt-vm-5&quot;,
  &quot;Ready&quot;
]
[
  &quot;libvirt-vm-6&quot;,
  &quot;Deployed&quot;
]
</code></pre>
<p>So much for printing the values of JSON keys. There are still some nuances (arrays, nested keys, …), but this is the lion&rsquo;s share of the syntax. Let&rsquo;s divert for a minute and look at how to format the output in a more human-readable way.</p>
<p><a href="#heading--Improved-formatting"><h2 id="heading--Improved-formatting">Improved formatting</h2></a></p>
<p>Most of the Ubuntu text-processing commands use tabs as field delimiters, which is a trait inherited from grandfather UNIX. Currently, the output is clean, but relatively hard to format into lines. Luckily jq has a filter for this: the “tab-separated values” filter, known as @tsv. This filter transforms the output records into individual lines with values separated by tabs.</p>
<p>Adding @tsv to the mix:</p>
<pre><code class="language-nohighlight">maas admin machines read | jq '(.[] | [.hostname, .status_name]) | @tsv'
</code></pre>
<p>we get something like this:</p>
<pre><code class="language-nohighlight">&quot;lxd-vm-1\tDeployed&quot;
&quot;lxd-vm-2\tAllocated&quot;
&quot;lxd-vm-3\tReady&quot;
&quot;lxd-vm-4\tDeployed&quot;
&quot;lxd-vm-5\tAllocated&quot;
&quot;lxd-vm-6\tNew&quot;
&quot;libvirt-vm-1\tReady&quot;
&quot;libvirt-vm-2\tReady&quot;
&quot;libvirt-vm-3\tReady&quot;
&quot;libvirt-vm-4\tReady&quot;
&quot;libvirt-vm-5\tReady&quot;
&quot;libvirt-vm-6\tDeployed&quot;
</code></pre>
<p>That&rsquo;s a step in the right direction, but it&rsquo;s still pretty far from human-readable output. If only there were some way to get rid of the quotes and just do the tab, instead of representing it as a regex character. In fact, the jq “raw” output option (-r) takes care of this:</p>
<pre><code class="language-nohighlight">maas admin machines read | jq -r '(.[] | [.hostname, .status_name]) | @tsv'
</code></pre>
<p>Feeding the raw output into our three-filter set gives us a more readable result:</p>
<pre><code class="language-nohighlight">lxd-vm-1    Deployed
lxd-vm-2    Allocated
lxd-vm-3    Ready
lxd-vm-4    Deployed
lxd-vm-5    Allocated
lxd-vm-6    New
libvirt-vm-1    Ready
libvirt-vm-2    Ready
libvirt-vm-3    Ready
libvirt-vm-4    Ready
libvirt-vm-5    Ready
libvirt-vm-6    Deployed
</code></pre>
<p>This is tabulated, but the number of spaces between the columns is a little big, and, if there&rsquo;s an unusually long value in one of the fields, it may throw the tabulation off for that line. Something could have been added to jq for that, but there is no need, since Ubuntu already has the column utility. Piping the output of the command so far to column -t (-t for “tabs”) will normalise the tab spacing to the data and ensure that each column is exactly long enough for the longest value in that column:</p>
<pre><code class="language-nohighlight">maas admin machines read | jq -r '(.[] | [.hostname, .status_name]) | @tsv' | column -t
</code></pre>
<p>This command result is very similar to the previous output, though you&rsquo;ll notice that the field spacing is neatly optimised to the data itself:</p>
<pre><code class="language-nohighlight">lxd-vm-1      Deployed
lxd-vm-2      Allocated
lxd-vm-3      Ready
lxd-vm-4      Deployed
lxd-vm-5      Allocated
lxd-vm-6      New
libvirt-vm-1  Ready
libvirt-vm-2  Ready
libvirt-vm-3  Ready
libvirt-vm-4  Ready
libvirt-vm-5  Ready
libvirt-vm-6  Deployed
</code></pre>
<p><a href="#heading--Making-real-tables"><h2 id="heading--Making-real-tables">Making real tables</h2></a></p>
<p>So far, so good, but this still isn&rsquo;t a presentable data table. First of all, there are no headings. These can be added by passing a literal row to jq, like this:</p>
<pre><code class="language-nohighlight">maas admin machines read | jq -r '([&quot;HOSTNAME&quot;,&quot;STATUS&quot;]), (.[] | [.hostname, .status_name]) | @tsv' | column -t
</code></pre>
<p>You&rsquo;ll note that there are two expressions in parenthesis (representing individual lines or rows). The first just contains the two column headings, while the second contains the “for each” construct that pulls the hostname and status out of the JSON. In essence, the first expression evaluates to just one row, since there&rsquo;s nothing to tell it to iterate. The second expression evaluates to one row per machine, since that&rsquo;s the level of data we&rsquo;re reading. Here&rsquo;s what we get from this command:</p>
<pre><code class="language-nohighlight">HOSTNAME      STATUS
lxd-vm-1      Deployed
lxd-vm-2      Allocated
lxd-vm-3      Ready
lxd-vm-4      Deployed
lxd-vm-5      Allocated
lxd-vm-6      New
libvirt-vm-1  Ready
libvirt-vm-2  Ready
libvirt-vm-3  Ready
libvirt-vm-4  Ready
libvirt-vm-5  Ready
libvirt-vm-6  Deployed
</code></pre>
<p>Nice, but it needs a horizontal rule, like a line of dashes, to separate the headings from the data. We can do this by essentially turning the one header row into two, using some jq macros to generate dashes lines of appropriate length:</p>
<pre><code class="language-nohighlight">maas admin machines read | jq -r '([&quot;HOSTNAME&quot;,&quot;STATUS&quot;] | 
(.,map(length*&quot;-&quot;))), (.[] | [.hostname, .status_name]) | @tsv' | column -t
</code></pre>
<p>The expression | (.,) tells jq to convert the foregoing header row into two rows: the first contains the two headers, as in the previous row, and the second contains the result of a couple of macros (map and length). We won&rsquo;t detail those here, but the use of this construct produces the following output:</p>
<pre><code class="language-nohighlight">HOSTNAME      STATUS
--------      ------
lxd-vm-1      Deployed
lxd-vm-2      Allocated
lxd-vm-3      Ready
lxd-vm-4      Deployed
lxd-vm-5      Allocated
lxd-vm-6      New
libvirt-vm-1  Ready
libvirt-vm-2  Ready
libvirt-vm-3  Ready
libvirt-vm-4  Ready
libvirt-vm-5  Ready
libvirt-vm-6  Deployed
</code></pre>
<p><a href="#heading--Extending-the-list"><h2 id="heading--Extending-the-list">Extending the list</h2></a></p>
<p>Let&rsquo;s add a couple more fields, owner (which is sometimes blank), and system_id (which is never blank), to the output:</p>
<pre><code class="language-nohighlight">maas admin machines read | jq -r '([&quot;HOSTNAME&quot;,&quot;STATUS&quot;, &quot;OWNER&quot;, &quot;SYSTEM-ID&quot;] 
| (.,map(length*&quot;-&quot;))), (.[] | [.hostname, .status_name,.owner,.system_id]) 
| @tsv' | column -t
</code></pre>
<p>This gives us the following result:</p>
<pre><code class="language-nohighlight">HOSTNAME      STATUS     OWNER   SYSTEM-ID
--------      ------     -----   ---------
lxd-vm-1      Deployed   admin   r8d6yp
lxd-vm-2      Allocated  admin   tfftrx
lxd-vm-3      Ready      grwpwc  
lxd-vm-4      Deployed   admin   6s8dt4
lxd-vm-5      Allocated  admin   pyebgm
lxd-vm-6      New        ebnww6  
libvirt-vm-1  Ready      m7ffsg  
libvirt-vm-2  Ready      kpawad  
libvirt-vm-3  Ready      r44hr6  
libvirt-vm-4  Ready      s3sdkw  
libvirt-vm-5  Ready      48dg8m  
libvirt-vm-6  Deployed   admin   bacx77
</code></pre>
<p>You&rsquo;ll notice right away there&rsquo;s a problem with the columns. Remember that only machines in the “Allocated” or “Deployed” state are owned by anyone, since that&rsquo;s what allocate/acquire means. The lines for the deployed and allocated machines lay out correctly, but the lines for the unowned machines are incorrectly formatted. We can fix this by using the jq “alternate value” construct (a // &ldquo;b&rdquo;), which can be loosely read, “if not a, then b.” We add it to the owner key like this:</p>
<pre><code class="language-nohighlight">maas admin machines read | jq -r '([&quot;HOSTNAME&quot;,&quot;STATUS&quot;, &quot;OWNER&quot;, &quot;SYSTEM-ID&quot;] 
| (.,map(length*&quot;-&quot;))), (.[] | [.hostname, .status_name,.owner // &quot;-&quot;,.system_id]) 
| @tsv' | column -t
</code></pre>
<p>Then the results line up nicely, based on the longest value in each key column:</p>
<pre><code class="language-nohighlight">HOSTNAME      STATUS     OWNER  SYSTEM-ID
--------      ------     -----  ---------
lxd-vm-1      Deployed   admin  r8d6yp
lxd-vm-2      Allocated  admin  tfftrx
lxd-vm-3      Ready      -      grwpwc
lxd-vm-4      Deployed   admin  6s8dt4
lxd-vm-5      Allocated  admin  pyebgm
lxd-vm-6      New        -      ebnww6
libvirt-vm-1  Ready      -      m7ffsg
libvirt-vm-2  Ready      -      kpawad
libvirt-vm-3  Ready      -      r44hr6
libvirt-vm-4  Ready      -      s3sdkw
libvirt-vm-5  Ready      -      48dg8m
libvirt-vm-6  Deployed   admin  bacx77
</code></pre>
<p><a href="#heading--Nested-arrays"><h2 id="heading--Nested-arrays">Nested arrays</h2></a></p>
<p>Machines have a nested array (of indeterminate length) for machine tags. In JSON terms, instead of having a single key-value pair at the top level, like this:</p>
<pre><code class="language-nohighlight">&quot;hostname&quot;: &quot;libvirt-vm-6&quot;,
</code></pre>
<p>tags are represented by nested arrays, like this:</p>
<pre><code class="language-nohighlight">&quot;tag_names&quot;: [
    &quot;pod-console-logging&quot;,
    &quot;virtual&quot;
],
</code></pre>
<p>Incorporating a random number of tags per machine into a neat table is beyond the scope of this particular post, but we can show the first tag in the table rows:</p>
<pre><code class="language-nohighlight">maas admin machines read | jq -r '([&quot;HOSTNAME&quot;,&quot;STATUS&quot;, &quot;OWNER&quot;, &quot;SYSTEM-ID&quot;,
&quot;FIRST TAG&quot;] | (.,map(length*&quot;-&quot;))), (.[] | [.hostname, .status_name,
.owner // &quot;-&quot;,.system_id,.tag_names[0] // &quot;-&quot;]) | @tsv' | column -t
</code></pre>
<p>Where we would use .json-key-name for a non-nested value, we need only use .json-key-name[0] to refer to the first element of the nested array. Doing this produces the following result:</p>
<pre><code class="language-nohighlight">HOSTNAME      STATUS     OWNER  SYSTEM-ID  FIRST                TAG
--------      ------     -----  ---------  ---------            
lxd-vm-1      Deployed   admin  r8d6yp     pod-console-logging  
lxd-vm-2      Allocated  admin  tfftrx     pod-console-logging  
lxd-vm-3      Ready      -      grwpwc     pod-console-logging  
lxd-vm-4      Deployed   admin  6s8dt4     pod-console-logging  
lxd-vm-5      Allocated  admin  pyebgm     pod-console-logging  
lxd-vm-6      New        -      ebnww6     pod-console-logging  
libvirt-vm-1  Ready      -      m7ffsg     pod-console-logging  
libvirt-vm-2  Ready      -      kpawad     pod-console-logging  
libvirt-vm-3  Ready      -      r44hr6     pod-console-logging  
libvirt-vm-4  Ready      -      s3sdkw     pod-console-logging  
libvirt-vm-5  Ready      -      48dg8m     pod-console-logging  
libvirt-vm-6  Deployed   admin  bacx77     pod-console-logging
</code></pre>
<p>That&rsquo;s almost right, but notice that the heading separates on spaces between words. Let&rsquo;s try a better way, with an underscore:</p>
<pre><code class="language-nohighlight">maas admin machines read | jq -r '([&quot;HOSTNAME&quot;,&quot;STATUS&quot;, &quot;OWNER&quot;, &quot;SYSTEM-ID&quot;,
&quot;FIRST_TAG&quot;] | (.,map(length*&quot;-&quot;))), (.[] | [.hostname, .status_name,
.owner // &quot;-&quot;,.system_id,.tag_names[0] // &quot;-&quot;]) | @tsv' | column -t
</code></pre>
<p>This version of the command produces the expected output:</p>
<pre><code class="language-nohighlight">HOSTNAME      STATUS     OWNER  SYSTEM-ID  FIRST_TAG
--------      ------     -----  ---------  ---------
lxd-vm-1      Deployed   admin  r8d6yp     pod-console-logging
lxd-vm-2      Allocated  admin  tfftrx     pod-console-logging
lxd-vm-3      Ready      -      grwpwc     pod-console-logging
lxd-vm-4      Deployed   admin  6s8dt4     pod-console-logging
lxd-vm-5      Allocated  admin  pyebgm     pod-console-logging
lxd-vm-6      New        -      ebnww6     pod-console-logging
libvirt-vm-1  Ready      -      m7ffsg     pod-console-logging
libvirt-vm-2  Ready      -      kpawad     pod-console-logging
libvirt-vm-3  Ready      -      r44hr6     pod-console-logging
libvirt-vm-4  Ready      -      s3sdkw     pod-console-logging
libvirt-vm-5  Ready      -      48dg8m     pod-console-logging
libvirt-vm-6  Deployed   admin  bacx77     pod-console-logging
</code></pre>
<p><a href="#heading--Nested-keys"><h2 id="heading--Nested-keys">Nested keys</h2></a></p>
<p>These aren&rsquo;t all the routine key-value pairs we want in the table, though. It would also be nice to print the pool to which each machine is assigned. Just asking for .pool as a single key-value pair:</p>
<pre><code class="language-nohighlight">maas admin machines read | jq -r '([&quot;HOSTNAME&quot;,&quot;STATUS&quot;, &quot;OWNER&quot;, &quot;SYSTEM-ID&quot;,
&quot;FIRST_TAG&quot;,&quot;POOL&quot;] | (.,map(length*&quot;-&quot;))), (.[] | [.hostname, .status_name,
.owner // &quot;-&quot;,.system_id,.tag_names[0] // &quot;-&quot;, .pool]) | @tsv' | column -t
</code></pre>
<p>produces an error:</p>
<pre><code class="language-nohighlight">jq: error (at &amp;lt;stdin&amp;gt;:5639): object ({&quot;name&quot;:&quot;de...&quot;) is not valid in a csv row
</code></pre>
<p>Looking at the JSON output, we see that .pool is a nested key, not a key-value pair:</p>
<pre><code class="language-nohighlight">&quot;pool&quot;: {
    &quot;name&quot;: &quot;default&quot;,
    &quot;description&quot;: &quot;Default pool&quot;,
    &quot;id&quot;: 0,
    &quot;resource_uri&quot;: &quot;/MAAS/api/2.0/resourcepool/0/&quot;
},
</code></pre>
<p>What we really want is the pool name, so we need to add one level of indirection to that particular key to reach the actual key-value pair, like this:</p>
<pre><code class="language-nohighlight">maas admin machines read | jq -r '([&quot;HOSTNAME&quot;,&quot;STATUS&quot;, &quot;OWNER&quot;, &quot;SYSTEM-ID&quot;,
&quot;FIRST_TAG&quot;,&quot;POOL&quot;] | (.,map(length*&quot;-&quot;))), (.[] | [.hostname, .status_name,
.owner // &quot;-&quot;,.system_id,.tag_names[0] // &quot;-&quot;, .pool.name]) | @tsv' | column -t
</code></pre>
<p>which gives us what we want:</p>
<pre><code class="language-nohighlight">HOSTNAME      STATUS     OWNER  SYSTEM-ID  FIRST_TAG            POOL
--------      ------     -----  ---------  ---------            ----
lxd-vm-1      Deployed   admin  r8d6yp     pod-console-logging  default
lxd-vm-2      Allocated  admin  tfftrx     pod-console-logging  default
lxd-vm-3      Ready      -      grwpwc     pod-console-logging  default
lxd-vm-4      Deployed   admin  6s8dt4     pod-console-logging  default
lxd-vm-5      Allocated  admin  pyebgm     pod-console-logging  default
lxd-vm-6      New        -      ebnww6     pod-console-logging  default
libvirt-vm-1  Ready      -      m7ffsg     pod-console-logging  default
libvirt-vm-2  Ready      -      kpawad     pod-console-logging  default
libvirt-vm-3  Ready      -      r44hr6     pod-console-logging  default
libvirt-vm-4  Ready      -      s3sdkw     pod-console-logging  default
libvirt-vm-5  Ready      -      48dg8m     pod-console-logging  default
libvirt-vm-6  Deployed   admin  bacx77     pod-console-logging  default
</code></pre>
<p>It&rsquo;s also useful to list the VLAN and fabric names in the output table. Looking at the JSON again, these values present like this:</p>
<pre><code class="language-nohighlight">&quot;boot_interface&quot;: {
        &quot;vlan&quot;: {
        &quot;vid&quot;: 0,
        &quot;mtu&quot;: 1500,
        &quot;dhcp_on&quot;: true,
        &quot;external_dhcp&quot;: null,
        &quot;relay_vlan&quot;: null,
        &quot;secondary_rack&quot;: null,
        &quot;name&quot;: &quot;untagged&quot;,
        &quot;id&quot;: 5001,
        &quot;fabric_id&quot;: 1,
        &quot;space&quot;: &quot;undefined&quot;,
        &quot;fabric&quot;: &quot;fabric-1&quot;,
        &quot;primary_rack&quot;: &quot;wnmkpn&quot;,
        &quot;resource_uri&quot;: &quot;/MAAS/api/2.0/vlans/5001/&quot;
         },
</code></pre>
<p>This means they are doubly-nested. No problem; just use double indirection (two levels of . separators) to retrieve them:</p>
<pre><code class="language-nohighlight">maas admin machines read | jq -r '([&quot;HOSTNAME&quot;,&quot;SYSID&quot;,&quot;POWER&quot;,&quot;STATUS&quot;,&quot;OWNER&quot;, 
&quot;TAGS&quot;, &quot;POOL&quot;, &quot;VLAN&quot;,&quot;FABRIC&quot;] | (., map(length*&quot;-&quot;))), (.[] | [.hostname, 
.system_id, .power_state, .status_name, .owner // &quot;-&quot;, .tag_names[0] // &quot;-&quot;, 
.pool.name, .boot_interface.vlan.name, .boot_interface.vlan.fabric]) 
| @tsv' | column -t
</code></pre>
<p>The modified command yields the desired results:</p>
<pre><code class="language-nohighlight">HOSTNAME      SYSID   POWER  STATUS     OWNER  TAGS                 POOL     VLAN      FABRIC
--------      -----   -----  ------     -----  ----                 ----     ----      ------
lxd-vm-1      r8d6yp  off    Deployed   admin  pod-console-logging  default  untagged  fabric-1
lxd-vm-2      tfftrx  off    Allocated  admin  pod-console-logging  default  untagged  fabric-1
lxd-vm-3      grwpwc  off    Ready      -      pod-console-logging  default  untagged  fabric-1
lxd-vm-4      6s8dt4  off    Deployed   admin  pod-console-logging  default  untagged  fabric-1
lxd-vm-5      pyebgm  off    Allocated  admin  pod-console-logging  default  untagged  fabric-1
lxd-vm-6      ebnww6  off    New        -      pod-console-logging  default  untagged  fabric-1
libvirt-vm-1  m7ffsg  off    Ready      -      pod-console-logging  default  untagged  fabric-1
libvirt-vm-2  kpawad  off    Ready      -      pod-console-logging  default  untagged  fabric-1
libvirt-vm-3  r44hr6  error  Ready      -      pod-console-logging  default  untagged  fabric-1
libvirt-vm-4  s3sdkw  off    Ready      -      pod-console-logging  default  untagged  fabric-1
libvirt-vm-5  48dg8m  off    Ready      -      pod-console-logging  default  untagged  fabric-1
libvirt-vm-6  bacx77  on     Deployed   admin  pod-console-logging  default  untagged  fabric-1
</code></pre>
<p>There&rsquo;s just one more (deeply nested) value we want to retrieve, and that&rsquo;s the fully-qualified subnet address in CIDR form. That&rsquo;s a little trickier, because it&rsquo;s buried in JSON like this:</p>
<pre><code class="language-nohighlight">&quot;boot_interface&quot;: {
     &quot;vlan&quot;: {
     &quot;vid&quot;: 0,
     &quot;mtu&quot;: 1500,
     &quot;dhcp_on&quot;: true,
     ...
     &quot;resource_uri&quot;: &quot;/MAAS/api/2.0/vlans/5001/&quot;
     },
     &quot;parents&quot;: [],
     &quot;product&quot;: null,
     ...
     &quot;link_connected&quot;: true,
     &quot;type&quot;: &quot;physical&quot;,
     &quot;links&quot;: [
     {
         &quot;id&quot;: 79,
         &quot;mode&quot;: &quot;auto&quot;,
         &quot;ip_address&quot;: &quot;10.124.141.4&quot;,
         &quot;subnet&quot;: {
         &quot;name&quot;: &quot;10.124.141.0/24&quot;,
</code></pre>
<p>So the value we want is in the nested key boot_interface, in a nested array links[], which contains the doubly-nested key subnet.name. We can finish our basic CLI machine list — the one we started with — by adding this complex formulation to the command:</p>
<pre><code class="language-nohighlight">maas admin machines read | jq -r '([&quot;HOSTNAME&quot;,&quot;SYSID&quot;,&quot;POWER&quot;,&quot;STATUS&quot;,
&quot;OWNER&quot;, &quot;TAGS&quot;, &quot;POOL&quot;, &quot;VLAN&quot;,&quot;FABRIC&quot;,&quot;SUBNET&quot;] | (., map(length*&quot;-&quot;))),
(.[] | [.hostname, .system_id, .power_state, .status_name, .owner // &quot;-&quot;, 
.tag_names[0] // &quot;-&quot;, .pool.name,
.boot_interface.vlan.name, .boot_interface.vlan.fabric,
.boot_interface.links[0].subnet.name]) | @tsv' | column -t
</code></pre>
<p>Sure enough, this command gives us the same table we had at the beginning of this post:</p>
<pre><code class="language-nohighlight">HOSTNAME      SYSID   POWER  STATUS     OWNER  TAGS                 POOL     VLAN      FABRIC    SUBNET
--------      -----   -----  ------     -----  ----                 ----     ----      ------    ------
lxd-vm-1      r8d6yp  off    Deployed   admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-2      tfftrx  off    Allocated  admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-3      grwpwc  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-4      6s8dt4  off    Deployed   admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-5      pyebgm  off    Allocated  admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-6      ebnww6  off    New        -      pod-console-logging  default  untagged  fabric-1  
libvirt-vm-1  m7ffsg  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-2  kpawad  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-3  r44hr6  error  Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-4  s3sdkw  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-5  48dg8m  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-6  bacx77  on     Deployed   admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
</code></pre>
<p><a href="#heading--Chaining-Ubuntu-CLI-commands"><h2 id="heading--Chaining-Ubuntu-CLI-commands">Chaining Ubuntu CLI commands</h2></a></p>
<p>Although the machine list above looks fairly neat, it&rsquo;s actually not sorted by hostname, exactly. To accomplish this, we&rsquo;d need to add a couple of Ubuntu CLI commands to the mix. Sorting on hostname means we want to sort on field 1 of the current command&rsquo;s output. We can try just feeding that to sort like this:</p>
<pre><code class="language-nohighlight">maas admin machines read | jq -r '([&quot;HOSTNAME&quot;,&quot;SYSID&quot;,&quot;POWER&quot;,&quot;STATUS&quot;, &quot;OWNER&quot;, 
&quot;TAGS&quot;, &quot;POOL&quot;, &quot;VLAN&quot;,&quot;FABRIC&quot;,&quot;SUBNET&quot;] | (., map(length*&quot;-&quot;))), (.[] | 
[.hostname, .system_id, .power_state, .status_name, .owner // &quot;-&quot;, 
.tag_names[0] // &quot;-&quot;, .pool.name, .boot_interface.vlan.name, 
.boot_interface.vlan.fabric, .boot_interface.links[0].subnet.name]) 
| @tsv' | column -t | sort -k 1
</code></pre>
<p>This command does indeed sort by hostname:</p>
<pre><code class="language-nohighlight">--------      -----   -----  ------     -----  ----                 ----     ----      ------    ------
HOSTNAME      SYSID   POWER  STATUS     OWNER  TAGS                 POOL     VLAN      FABRIC    SUBNET
libvirt-vm-1  m7ffsg  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-2  kpawad  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-3  r44hr6  error  Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-4  s3sdkw  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-5  48dg8m  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-6  bacx77  on     Deployed   admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-1      r8d6yp  off    Deployed   admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-2      tfftrx  off    Allocated  admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-3      grwpwc  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-4      6s8dt4  off    Deployed   admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-5      pyebgm  off    Allocated  admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-6      ebnww6  off    New        -      pod-console-logging  default  untagged  fabric-1
</code></pre>
<p>but it has the unintended side-effect of sorting the header lines into the output. There are probably at least a dozen Ubuntu CLI solutions for this, so we&rsquo;ll just pick one of the most elegant here, using awk:</p>
<pre><code class="language-nohighlight">maas admin machines read | jq -r '([&quot;HOSTNAME&quot;,&quot;SYSID&quot;,&quot;POWER&quot;,&quot;STATUS&quot;,&quot;OWNER&quot;, 
&quot;TAGS&quot;, &quot;POOL&quot;, &quot;VLAN&quot;,&quot;FABRIC&quot;,&quot;SUBNET&quot;] | (., map(length*&quot;-&quot;))),(.[] | 
[.hostname, .system_id, .power_state, .status_name, .owner // &quot;-&quot;, 
.tag_names[0] // &quot;-&quot;, .pool.name, .boot_interface.vlan.name, 
.boot_interface.vlan.fabric,.boot_interface.links[0].subnet.name]) 
| @tsv' | column -t | awk 'NR&amp;lt;3{print $0;next}{print $0| &quot;sort -k 1&quot;}'
</code></pre>
<p>This command gives us the desired output:</p>
<pre><code class="language-nohighlight">HOSTNAME      SYSID   POWER  STATUS     OWNER  TAGS                 POOL     VLAN      FABRIC    SUBNET
--------      -----   -----  ------     -----  ----                 ----     ----      ------    ------
libvirt-vm-1  m7ffsg  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-2  kpawad  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-3  r44hr6  error  Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-4  s3sdkw  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-5  48dg8m  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-6  bacx77  on     Deployed   admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-1      r8d6yp  off    Deployed   admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-2      tfftrx  off    Allocated  admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-3      grwpwc  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-4      6s8dt4  off    Deployed   admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-5      pyebgm  off    Allocated  admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-6      ebnww6  off    New        -      pod-console-logging  default  untagged  fabric-1
</code></pre>
<p>Note that by changing the numerical “-k” argument to “sort,” you can change which field controls the sort:</p>
<pre><code class="language-nohighlight">maas admin machines read | jq -r '([&quot;HOSTNAME&quot;,&quot;SYSID&quot;,&quot;POWER&quot;,&quot;STATUS&quot;,&quot;OWNER&quot;, 
&quot;TAGS&quot;, &quot;POOL&quot;, &quot;VLAN&quot;,&quot;FABRIC&quot;,&quot;SUBNET&quot;] | (., map(length*&quot;-&quot;))),(.[] | 
[.hostname, .system_id, .power_state, .status_name, .owner // &quot;-&quot;, 
.tag_names[0] // &quot;-&quot;, .pool.name, .boot_interface.vlan.name, 
.boot_interface.vlan.fabric,.boot_interface.links[0].subnet.name]) 
| @tsv' | column -t | awk 'NR&amp;lt;3{print $0;next}{print $0| &quot;sort -k 4&quot;}'
</code></pre>
<p>This command sorts by machine state, which is the fourth field:</p>
<pre><code class="language-nohighlight">HOSTNAME      SYSID   POWER  STATUS     OWNER  TAGS                 POOL     VLAN      FABRIC    SUBNET
--------      -----   -----  ------     -----  ----                 ----     ----      ------    ------
lxd-vm-2      tfftrx  off    Allocated  admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-5      pyebgm  off    Allocated  admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-6  bacx77  on     Deployed   admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-1      r8d6yp  off    Deployed   admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-4      6s8dt4  off    Deployed   admin  pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-6      ebnww6  off    New        -      pod-console-logging  default  untagged  fabric-1  
libvirt-vm-1  m7ffsg  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-2  kpawad  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-4  s3sdkw  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-5  48dg8m  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
lxd-vm-3      grwpwc  off    Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
libvirt-vm-3  r44hr6  error  Ready      -      pod-console-logging  default  untagged  fabric-1  10.124.141.0/24
</code></pre>
<p><a href="#heading--Summary"><h2 id="heading--Summary">Summary</h2></a></p>
<p>At this point, it should be clear that jq is a relatively simple, powerful tool for formatting output from the MAAS CLI. You should also remember that, like any Ubuntu CLI command, jq simply outputs text — so anything you can do with text output, you can do with the output from jq.</p>
    </div>
  </body>
</html>