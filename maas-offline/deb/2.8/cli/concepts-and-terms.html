<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" type="text/css" href="css/stylesheet.css" />
    <style>
      #selector a:link{color:black;}
      #selector a:visited{color:black;}
      #selector a:active{color:black;}
      #selector a:hover{color:blue;}
      #sidebar a:link{color:black;}
      #sidebar a:visited{color:black;}
      #sidebar a:active{color:black;}
      #sidebar a:hover{color:blue;}
      ul {margin-left:0;list-style-type:none;}
      li {margin: 4px 0;}
    </style>
  </head>
  <body>
    <div id="selector" style="top:0; position:fixed; float:right; background-color:#d9d9d9; width:100%;border-bottom:1px solid black;">
      &nbsp;&nbsp;<strong>Offline docs</strong>
      <a href="https://maas.io/docs">(switch to live docs)</a>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<a href="../ui/concepts-and-terms.html">
	  &nbsp;UI-only&nbsp;
	</a>
      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      <span style="background-color:white;border-top:1px solid black; border-left:1px solid black; border-right:1px solid black; border-bottom:5px solid white;">
	  CLI-only
      </span>
    </div>
    <div id="sidebar" style="float:left; width:25%;margin-top:40px; margin-left:20px">
      <strong>
	<a href="maas-documentation.html">
	  Introduction
	</a>
      </strong>
      <ul>
	<li>
	  <a href="about-maas.html">
	    About MAAS
	  </a>
	</li>
	<li>
	  <a href="give-me-an-example-of-maas.html">
	    &ldquo;Give me an example&rdquo;
	  </a>
	</li>
	<li>
	  <a href="whats-new-in-maas.html">
	    What&rsquo;s new in 2.8
	  </a>
	</li>
	<li>
	  <a href="maas-requirements.html">
	    Requirements
	  </a>
	</li>
	<li>
	  <a href="maas-installation.html">
	    Installation
	  </a>
	</li>
	<li>
	  <a href="configuration-journey.html">
	    Configuration journey
	  </a>
	</li>
      <strong>
	<a href="controllers.html">
	  Controllers
	</a>
      </strong>
      <ul>
	<li>
	  <a href="maas-communication.html">
	    Communication
	  </a>
	</li>
	<li>
	  <a href="rack-controllers.html">
	    Rack controllers
	  </a>
	</li>
	<li>
	  <a href="region-controllers.html">
	    Region controllers
	  </a>
	</li>
	<li>
	  <a href="high-availability.html">
	    High availability
	  </a>
	</li>
      </ul>
      <strong>
	<a href="machines.html">
	  Machines
	</a>
      </strong>
      <ul>
	<li>
	  <a href="add-machines.html">
	    Add machines
	  </a>
	</li>
	<li>
	  <a href="power-management.html">
	    Power management
	  </a>
	</li>
	<li>
	  <a href="commission-machines.html">
	    Commission machines
	  </a>
	</li>
	<li>Testing
	</li>
	<li>
	  <a href="hardware-testing.html">
	    Hardware testing
	  </a>
	</li>
	<li>
	  <a href="network-testing.html">
	    Network testing
	  </a>
	</li>
	<li>
	  <a href="commissioning-and-hardware-testing-scripts.html">
	    Commissioning and hardware testing scripts
	  </a>
	</li>
	<li>
	  <a href="deploy-machines.html">
	    Deploy machines
	  </a>
	</li>
	<li>
	  <a href="maas-tags.html">
	    Tags
	  </a>
	</li>
	<li>
	  <a href="custom-machine-setup.html">
	    Custom machine setup
	  </a>
	</li>
	<li>
	  <a href="kernel-boot-options.html">
	    Kernel boot options
	  </a>
	</li>
	<li>
	  <a href="resource-pools.html">
	    Resource pools
	  </a>
	</li>
	<li>
	  <a href="storage.html">
	    Storage
	  </a>
	</li>
	<li>
	  <a href="vmware-vmfs-datastores.html">
	    VMware VMFS datastores
	  </a>
	</li>
	<li>
	  <a href="ubuntu-kernels.html">
	    Ubuntu kernels
	  </a>
	</li>
      </ul>
      <strong>
	<a href="images.html">
	  Images
	</a>
      </strong>
      <ul>
	<li>
	  <a href="select-and-import-images.html">
	    Select and import images
	  </a>
	</li>
	<li>
	  <a href="local-image-mirror.html">
	    Local image mirror
	  </a>
	</li>
	<li>
	  <a href="vmware-images.html">
	    VMWare images
	  </a>
	</li>
      </ul>
      <strong>
	<a href="networking.html">
	  Networking
	</a>
      </strong>
      <ul>
	<li>
	  <a href="subnet-management.html">
	    Subnet management
	  </a>
	</li>
	<li>
	  <a href="managing-dhcp.html">
	    DHCP
	  </a>
	</li>
	<li>
	  <a href="ip-ranges.html">
	    IP ranges
	  </a>
	</li>
	<li>
	  <a href="proxy.html">
	    Proxy
	  </a>
	</li>
	<li>
	  <a href="ntp-services.html">
	    NTP
	  </a>
	</li>
	<li>
	  <a href="network-discovery.html">
	    Network discovery
	  </a>
	</li>
	<li>
	  <a href="ipv6-addressing.html">
	    IPv6
	  </a>
	</li>
	<li>
	  <a href="configuring-tls-encryption.html">
	    SSL
	  </a>
	</li>
	<li>
	  <a href="managing-stp.html">
	    STP
	  </a>
	</li>
	<li>
	  <a href="availability-zones.html">
	    Availability zones (AZs)
	  </a>
	</li>
      </ul>
      <strong>
	<a href="vm-hosting.html">
	  VM hosting
	</a>
      </strong>
      <ul>
	<li>
	  <a href="vm-host-networking.html">
	    VM host networking
	  </a>
	</li>
	<li>
	  <a href="adding-a-vm-host.html">
	    Add a VM host
	  </a>
	</li>
	<li>
	  <a href="vm-host-storage-pools.html">
	    VM host storage pools
	  </a>
	</li>
	<li>
	  <a href="creating-and-deleting-vms.html">
	    Creating and deleting VMs
	  </a>
	</li>
      </ul>
      <strong>Operations
      </strong>
      <ul>
	<li>
	  <a href="prometheus-metrics.html">
	    Prometheus metrics
	  </a>
	</li>
	<li>
	  <a href="backup.html">
	    Backup
	  </a>
	</li>
	<li>
	  <a href="hardening-your-maas-installation.html">
	    MAAS security
	  </a>
	</li>
	<li>
	  <a href="maas-logging.html">
	    Logging
	  </a>
	</li>
	<li>
	  <a href="commissioning-logs.html">
	    Commissioning logs
	  </a>
	</li>
	<li>
	  <a href="user-accounts.html">
	    User accounts
	  </a>
	</li>
	<li>
	  <a href="interactive-search.html">
	    Interactive search
	  </a>
	</li>
      </ul>
      <strong>
	<a href="concepts-and-terms.html">
	  Concepts &amp; terms
	</a>
      </strong>
      <ul>
	<li>
	  <a href="concepts-and-terms.html#heading--network-tutorial">
	    Brief network tutorial
	  </a>
	</li>
      </ul>
      <strong>
	<a href="maas-cli.html">
	  CLI
	</a>
      </strong>
      <ul>
	<li>
	  <a href="common-cli-tasks.html">
	    The CLI cookbook
	  </a>
	</li>
	<li>
	  <a href="common-cli-tasks.html">
	    Common tasks
	  </a>
	</li>
	<li>
	  <a href="audit-event-logs.html">
	    Audit event logs
	  </a>
	</li>
	<li>
	  <a href="cli-kernel-management.html">
	    Kernel management
	  </a>
	</li>
	<li>
	  <a href="cli-image-management.html">
	    Image management
	  </a>
	</li>
	<li>
	  <a href="cli-interface-management.html">
	    Interface management
	  </a>
	</li>
	<li>
	  <a href="cli-advanced-tasks.html">
	    Advanced tasks
	  </a>
	</li>
	<li>
	  <a href="cli-composable-hardware.html">
	    Composable hardware
	  </a>
	</li>
	<li>
	  <a href="python-api-client.html">
	    API client
	  </a>
	</li>
      </ul>
      <strong>
	<a href="api.html">
	  API documentation
	</a>
      </strong>
      <ul>
	<li>
	  <a href="api-authentication.html">
	    API authentication
	  </a>
	</li>
      </ul>
      <strong>
	<a href="troubleshooting.html">
	  Troubleshoot
	</a>
      </strong>
      <ul>
	<li>
	  <a href="getting-help.html">
	    Getting help
	  </a>
	</li>
	<li>
	  <a href="tips-tricks-and-traps.html">
	    Tips, tricks, and traps
	  </a>
	</li>
	<li>
	  <a href="https://old-docs.maas.io/2.5/en/">
	    MAAS 2.5 (+ earlier) doc
	  </a>
	</li>
      </ul>
      <strong>
	<a href="whats-new-in-maas.html">
	  Release notes
	</a>
      </strong>
      <p/>
      <strong>
	<a href="writing-guide.html">
	  Help improve these docs
	</a>
      </strong>
    </div>
    <div class="container" style="float:right; width:65%; margin-top:40px; margin-right:30px">
      <h1>Concepts and terms</h1><p>Built on a foundation of networking knowledge, MAAS introduces a number of new terms, and adds some nuances to common terms.  Some of these terms may be common networking terms you never looked up; others represent more complex concepts that may be unique to MAAS.  This article presents and explains some of these important terms.</p>
<p><details><summary>Show me an alphabetical list of terms</summary></p>
<ul>
<li><a href="concepts-and-terms.html#heading--zones">Availability zones</a></li>
<li><a href="concepts-and-terms.html#heading--client">Client</a></li>
<li><a href="concepts-and-terms.html#heading--controllers">Controller</a></li>
<li><a href="concepts-and-terms.html#heading--devices">Device</a></li>
<li><a href="concepts-and-terms.html#heading--dhcp">DHCP</a></li>
<li><a href="concepts-and-terms.html#heading--dhcp-relay">DHCP relay</a></li>
<li><a href="concepts-and-terms.html#heading--edge-clouds">Edge clouds</a></li>
<li><a href="concepts-and-terms.html#heading--fabrics">Fabrics</a></li>
<li><a href="concepts-and-terms.html#heading--hub">Hub</a></li>
<li><a href="concepts-and-terms.html#heading--images">Images</a></li>
<li><a href="concepts-and-terms.html#heading--interfaces">Interfaces</a></li>
<li><a href="concepts-and-terms.html#heading--isolcpus">isolcpus</a></li>
<li><a href="concepts-and-terms.html#heading--lan">LAN</a></li>
<li><a href="concepts-and-terms.html#heading--mac-address">MAC address</a></li>
<li><a href="concepts-and-terms.html#heading--machines">Machine</a></li>
<li><a href="concepts-and-terms.html#heading--machine-actions">Machine actions</a></li>
<li><a href="concepts-and-terms.html#heading--node-statuses">Machine statuses</a></li>
<li><a href="concepts-and-terms.html#heading--MAN">MAN</a></li>
<li><a href="concepts-and-terms.html#heading--network-cable">Network cable</a></li>
<li><a href="concepts-and-terms.html#heading--network-infrastructure">Network infrastructure</a></li>
<li><a href="concepts-and-terms.html#heading--network-interface">Network interface</a></li>
<li><a href="concepts-and-terms.html#heading--network-topology">Network topology</a></li>
<li><a href="concepts-and-terms.html#heading--numa">NUMA</a></li>
<li><a href="concepts-and-terms.html#heading--nodes">Nodes</a></li>
<li><a href="package-repositories.html">Package repositories</a></li>
<li><a href="concepts-and-terms.html#heading--packet">Packet</a></li>
<li><a href="concepts-and-terms.html#heading--patch-panel">Patch panel</a></li>
<li><a href="concepts-and-terms.html#heading--regions">Regions</a></li>
<li><a href="concepts-and-terms.html#heading--repeater">Repeater</a></li>
<li><a href="concepts-and-terms.html#heading--router">Router</a></li>
<li><a href="concepts-and-terms.html#heading--series">Series</a></li>
<li><a href="concepts-and-terms.html#heading--server">Server</a></li>
<li><a href="concepts-and-terms.html#heading--spaces">Spaces</a></li>
<li><a href="concepts-and-terms.html#heading-sr-iov">SR-IOV</a></li>
<li><a href="concepts-and-terms.html#heading--subnets">Subnets</a></li>
<li><a href="concepts-and-terms.html#heading--switch">Switch</a></li>
<li><a href="concepts-and-terms.html#heading--tags">Tags</a></li>
<li><a href="concepts-and-terms.html#heading--vlans">VLAN</a></li>
<li><a href="concepts-and-terms.html#heading--vm-hosts">VM hosts</a></li>
<li><a href="concepts-and-terms.html#heading--WAN">WAN</a></li>
</ul>
<p></details></p>
<h2 id="heading--nodes">Nodes</h2>

<p>A node is a general term that refers to multiple, more specific objects. Nodes are managed by MAAS through a life cycle, from adding and enlistment into MAAS, through commissioning, allocation and deployment. Nodes are then either released back into the pool of nodes or retired.</p>
<p>Nodes include:</p>
<ul>
<li>Controllers</li>
<li>Machines</li>
<li>Devices</li>
</ul>
<p>See <a href="#heading--machine-actions">Machine actions</a> and <a href="#heading--machine-statuses">Machine statuses</a> below for an overview of a node&rsquo;s life cycle.</p>
<h3 id="heading--controllers">Controllers</h3>

<p>There are two types of controllers: a region controller and a rack controller. The region controller deals with operator requests while one or more rack controllers provide the high-bandwidth services to multiple server racks, as typically found in a data centre.</p>
<p>A region controller consists of:</p>
<ul>
<li>REST API server (TCP port 5240)</li>
<li>PostgreSQL database</li>
<li>DNS</li>
<li>caching HTTP proxy</li>
<li>web UI</li>
</ul>
<p>Think of a region controller can as being responsible for a data centre, or a single region. Multiple fabrics are used by MAAS to accommodate subdivisions within a single region, such as multiple floors in a data centre.</p>
<p>A rack controller provides:</p>
<ul>
<li>DHCP</li>
<li>TFTP</li>
<li>HTTP (for images)</li>
<li>power management</li>
</ul>
<p>A rack controller is attached to each &ldquo;fabric&rdquo;. As the name implies, a typical setup is to have a rack controller in each data centre server rack. The rack controller will cache large items for performance, such as operating system install images, but maintains no independent state other than the credentials required to talk to the region controller.</p>
<p>Both the region controller and the rack controller can be scaled-out as well as made highly available. See <a href="high-availability.html">MAAS HA</a> for high availability.</p>
<h3 id="heading--machines">Machines</h3>

<p>A machine is a node that can be deployed by MAAS.</p>
<h3 id="heading--devices">Devices</h3>

<p>A device is a non-deployable node. This entity can be used to track routers, for example.</p>
<p>Static or dynamic IP addresses and DNS names can be assigned to any device or parent node.  These addresses will be automatically deleted when the parent node is deleted or released, along with any IP address reservations.  This arrangement is designed to model and manage the virtual machines or containers running inside a MAAS-deployed node.</p>
<h2 id="heading--vm-hosts">VM hosts</h2>

<p>VM hosts, also called composable hardware, allow for the dynamic composition of machines from a pool of available hardware resources (e.g. disk space, memory, cores). See <a href="introduction-to-vm-hosting.html">Introduction to VM hosting</a> for details.</p>
<h2 id="heading--zones">Zones</h2>

<p>A physical zone, or just zone, is an organisational unit that contains nodes where each node is in one, and only one, zone. Later, while in production, a node can be taken (allocated) from a specific zone (or not from a specific zone). Since zones, by nature, are custom-designed (except for the &lsquo;default&rsquo; zone), they provide more flexibility than a similar feature offered by a public cloud service (ex: availability zones).</p>
<p>Some prime examples of zone usage include fault-tolerance, service performance, and power management. See <a href="zone-examples.html">Zone examples</a> for an elaboration.</p>
<p>A newly installed MAAS comes with a default zone which contains all nodes unless you create a new zone. You can therefore safely ignore the entire concept if you&rsquo;re not interested in leveraging zones.</p>
<p>You cannot remove the &lsquo;default&rsquo; zone or change its name.</p>
<h2 id="heading--regions">Regions</h2>

<p>A region is an organisational unit one level above a zone. It contains all information about all machines running in any possible zones. In particular, the PostgreSQL database runs at this level and maintains state for all these machines.</p>
<h2 id="heading--series">Series</h2>

<p>A series is essentially an operating system version. For Ubuntu, a series takes into account HWE kernels. In practical terms, a series manifests itself in the form of install images that are used to provision MAAS machines. The MAAS administrator can select series as desired.</p>
<h2 id="heading--images">Images</h2>

<p>An image is used to provision a machine. As soon as you install MAAS, images are imported based on what series you have selected.  MAAS won&rsquo;t work until it has imported the necessary images.</p>
<h2 id="heading--fabrics">Fabrics</h2>

<p>A <strong>fabric</strong> connects VLANs.  If you understand a VLAN, you know that they permit network connections only between specific switch ports or specifically identified ports (&ldquo;tagged&rdquo; ports). Consequently, it would be impossible for two VLANs to communicate with each other.  A fabric makes these VLAN-to-VLAN connections possible.</p>
<p><details><summary>Take me on a quick, deep dive on fabrics</summary></p>
<p>We can illustrate a network fabric more easily by rewinding the term to one of its earliest uses: the early phone system.  In a telephone switchboard, subscriber lines (customer phone numbers) ran in a grid pattern in the back of the switchboard, but they didn&rsquo;t touch each other until the operator inserted the plugs of a patch cable to join them.  With some &ldquo;plugboards&rdquo; (what a switchboard was actually called), an operator could conference multiple lines by adding more patch cords.</p>
<p>These patch cords essentially acted like a VLAN, allowing only the subscribers whose lines were &ldquo;patched in&rdquo; to join the conversation. </p>
<p>But the switchboard only covered one exchange, that is, one three-digit phone number prefix.  If a subscriber wanted to conference someone from another exchange, there had to be patch from one exchange to another.  This was handled by a long-distance operator.  Each exchange had a more robust outgoing line, called a &ldquo;trunk line,&rdquo; that connected exchanges in some central place.  The long-distance operators could bridge trunks in a specific way, involving a local operator in each of the &ldquo;bridged&rdquo; exchanges.</p>
<p>By now, you&rsquo;re probably starting to recognise a lot of network terms, which is completely appropriate.  Almost all modern networking technology originated in the telephone system.</p>
<p>Now imagine that you want to conference in six people, two in each of three distant exchanges.  Each exchange operator had to patch two numbers and a trunk line.  The long-distance operator had to patch three trunks in a specific way that prevented the conversation from going out to all numbers attached to the trunk.  </p>
<p>The details of the method aren&rsquo;t particularly relevant here, but it usually involved a pair of &ldquo;bridge clips&rdquo; that connected non-adjacent wire-crossings, with an insulated portion that laid across wires that weren&rsquo;t meant to be connected.  It looked a lot like a little bridge when properly placed.</p>
<p>Think of each of the local exchange conferences as a VLAN; the long-distance operator&rsquo;s patch cables created what was called a &ldquo;fabric.&rdquo;  Our use of fabric is exactly the same idea: some number of private &ldquo;conversations&rdquo; (connections) connected to each other so that specific people in each &ldquo;group&rdquo; can all talk to each other. </p>
<p></details></p>
<p>You could describe a fabric as a VLAN namespace. It&rsquo;s a switch or a combination of switches that use trunking to provide access to specific VLANs. MAAS creates a default fabric (&lsquo;fabric-0&rsquo;) for each detected subnet during installation.</p>
<p>The following conceptual diagram shows two fabrics in the same data centre or region, each using distinct VLAN ranges and their associated subnets:</p>
<p><a href="images/46177305128bf7f3190f8a7bbd037c33e96f6a9e.png" target = "_blank"><img src="images/46177305128bf7f3190f8a7bbd037c33e96f6a9e.png"></a></a></p>
<h2 id="heading--spaces">Spaces</h2>

<p>A space is a logical grouping of subnets that can communicate with one another. Spaces can be arranged to group subnets according to various parameters.  One of the most common examples is a DMZ space, which might group subnets presenting a web interface to the public Internet.  Behind this DMZ would be specific applications that aren&rsquo;t allowed to interact directly with the user, but instead must interact with a Web UI in the DMZ space.  MAAS does not create a default space during installation.</p>
<p>Spaces facilitate machine acquisition for <a href="https://jaas.ai/">Juju</a>. See <a href="https://jaas.ai/docs/spaces">Juju network spaces</a> for more details.</p>
<h2 id="heading--tags">Tags</h2>

<p>A tag (not to be confused with VLAN tags) is user-created and associated with nodes based on their physical properties. These can then be used to identify nodes with particular abilities which can be useful during the deployment of services.</p>
<h2 id="heading--subnets">Subnets</h2>

<p>A subnet is a &ldquo;layer 3&rdquo; network, defined by a network address and a network mask length (in bits) and usually written in &ldquo;CIDR&rdquo; format. MAAS supports IPv4 and IPv6 subnets. Examples include:</p>
<pre><code class="no-highlight">10.0.0.0/8
172.16.0.0/12
192.168.0.0/16
2001:db8:4d41:4153::/64
</code></pre>

<h3 id="heading--ip-ranges">IP ranges</h3>

<p>You can reserve IP addresses by adding one or more reserved ranges to a subnet configuration. You can define two types of ranges:</p>
<ul>
<li><strong>Reserved range</strong> Mode operates differently depending on whether the subnet is managed or unmanaged:<ul>
<li><strong>Managed (subnet)</strong>: MAAS will never assign IP addresses inside this range.  You can use this range for anything, such as infrastructure systems, network hardware, external DHCP, or an OpenStack namespace.</li>
<li><strong>Unmanaged (subnet)</strong>: MAAS will only assign IP addresses inside this range.</li>
</ul>
</li>
<li><strong>Reserved dynamic range</strong> An IP range that MAAS will use for enlisting, commissioning and, if enabled, MAAS-managed DHCP on the node&rsquo;s VLAN during commissioning, deploying. An initial range is created as part of the DHCP enablement process if done with the web UI. MAAS never uses IP addresses from this range for an unmanaged subnet.</li>
</ul>
<p>See <a href="ip-ranges.html">IP ranges</a> for how these ranges get created and <a href="commission-machines.html#heading--post-commission-configuration">Commission nodes</a> for how they get used and <a href="subnet-management.html">Subnet management</a> for information on managed vs. unmanaged subnets.</p>
<h2 id="heading--vlans">VLANs</h2>

<p>VLANs (Virtual LANs) are a common way to create logically separate networks using the same physical infrastructure.</p>
<p>Managed switches can assign VLANs to each port in either a &ldquo;tagged&rdquo; or an &ldquo;untagged&rdquo; manner. A VLAN is said to be &ldquo;untagged&rdquo; on a particular port when it is the default VLAN for that port and requires no special configuration to access it.</p>
<p>You can use also use tagged VLANs with MAAS nodes. If a switch port is configured to allow tagged VLAN frames from a MAAS node, that node can automatically access interfaces on that VLAN.</p>
<p>A &ldquo;Default VLAN&rdquo; is created for every fabric, to which every new VLAN-aware object in the fabric will be associated with by default (unless specified otherwise).</p>
<h2 id="heading--dhcp-relay">DHCP relay</h2>

<p>A DHCP relay, or relay agent, is a network device that forwards requests and replies between a DHCP client and a DHCP server when both are not on the same physical subnet.</p>
<p>Two common software implementations are <a href="http://packages.ubuntu.com/xenial/isc-dhcp-relay">isc-dhcp-relay</a> and <a href="http://packages.ubuntu.com/xenial/dhcp-helper">dhcp-helper</a>.</p>
<h2 id="heading--interfaces">Interfaces</h2>

<h3 id="heading--physical">Physical</h3>

<p>After a node is commissioned, MAAS discovers its physical interfaces.</p>
<p>MAAS always creates a device with at least one physical interface.</p>
<p>Before deployment, a MAAS administrator can configure additional interfaces on the node, including one or more of the types mentioned below.</p>
<h3 id="heading--bond">Bond</h3>

<p>A bond interface is capable of aggregating two or more physical interfaces into a single logical interface.  You can use bonds in conjunction with a managed switch (using Link Aggregation and Control Protocol, or LACP), or independently (software bonds).</p>
<h3 id="heading--vlan">VLAN</h3>

<p>A VLAN interface can be used to connect to a tagged VLAN, if the node is connected to an authorised port.</p>
<h3 id="heading--unknown">Unknown</h3>

<p>Unknown interfaces are sometimes discovered by MAAS. For example, a new DHCP lease that is not associated with any known node or device. Such an interface cannot be user-created.</p>
<h2 id="heading--machine-actions">Machine actions</h2>

<p>Machine actions are essentially &ldquo;things you can do with nodes&rdquo;. You can trigger them via the web UI or the MAAS CLI. In the web UI, you manage them with the &lsquo;Take action&rsquo; button in the top right corner. An action usually changes the status (see next section) of a node. Below is the full list of possible actions and their meaning, arranged alphabetically.</p>
<h3 id="heading--abort">Abort</h3>

<p>You can abort any action that permits retries. Currently, only commissioning and deployment permit retries.</p>
<h3 id="heading--acquire">Acquire</h3>

<p>Allocates (reserves) a node to the MAAS user performing the action (and currently logged in). Changes a node&rsquo;s status from &lsquo;Ready&rsquo; to &lsquo;Allocated&rsquo;.</p>
<p>With the CLI, it is necessary to perform this action before deploying. With the web UI, it is done automatically for the user. Acquiring in the web UI is used for machine reservation.</p>
<h3 id="heading--commission">Commission</h3>

<p>This action commissions a node, changing a node&rsquo;s status from &lsquo;New&rsquo; to &lsquo;Commissioning&rsquo; to &lsquo;Ready&rsquo;.</p>
<p>Commissioning enables MAAS to build a detailed inventory of RAM, CPU, storage, NICs and accelerators like GPUs. These are itemised and usable as constraints for machine selection.</p>
<p>If commissioning is unsuccessful, the status becomes &lsquo;Failed commissioning&rsquo;.</p>
<p>Any time a node&rsquo;s underlying networking or disk subsystem has changed, it should be re-commissioned. Typically, you would mark the node as &lsquo;Broken&rsquo; (see below), implement maintenance, and then Commission.</p>
<h3 id="heading--delete">Delete</h3>

<p>This action removes a node from MAAS. The underlying machine remains unaffected. Upon rebooting, it will be enlisted once more (status &lsquo;New&rsquo;).</p>
<h3 id="heading--deploy">Deploy</h3>

<p>This action, which includes &lsquo;Power on,&rsquo; deploys a node, changing a node&rsquo;s status from &lsquo;Ready&rsquo; (or &lsquo;Allocated&rsquo;) to a deployed status. </p>
<p>During deployment, MAAS turns on the machine and installs a complete server operating system without manual intervention, configuring network interfaces, disk partitions and more automatically.</p>
<p>If the deployment is unsuccessful, the status becomes &lsquo;Failed deployment&rsquo;.</p>
<p>Note that Juju, often used in conjunction with MAAS, also uses the term &ldquo;deploy&rdquo; to mean &ldquo;deploy an application&rdquo;.</p>
<h3 id="heading--exit-rescue-mode">Exit rescue mode</h3>

<p>This action changes a node&rsquo;s status from &lsquo;Rescue mode&rsquo; to the &lsquo;Exiting rescue mode&rsquo; transitory status and then back to its original status when the operation is complete.</p>
<h3 id="heading--mark-broken">Mark broken</h3>

<p>Marks a node as broken. Changes a node&rsquo;s status to &lsquo;Broken&rsquo;. Includes action &lsquo;Power off&rsquo;.</p>
<p>You can choose this action if any other action has failed (such as Commission and Deploy). If you mark a node broken, MAAS will not use it. This action would usually be followed by an investigation to determine the source of the problem.</p>
<p>By marking a node broken, you can also flag it for hardware maintenance that would affect MAAS, such as network or disk modifications. In this case, the original status would be &lsquo;Deployed&rsquo;.</p>
<p>You can also mark a newly-commissioned node (&lsquo;Ready&rsquo;) as &lsquo;Broken.&rsquo;</p>
<h3 id="heading--mark-fixed">Mark fixed</h3>

<p>This action fixes a broken node, changing its status from &lsquo;Broken&rsquo; to &lsquo;Ready&rsquo;.</p>
<h3 id="heading--lock">Lock</h3>

<p>This action marks a machine as locked, preventing the user from performing actions on machines that could change their state. For example, a locked machine cannot be mistakenly powered off or released.</p>
<p>A locked machine has a padlock symbol next to its name.</p>
<p><a href="images/7d1f0928fb599d465916e43e731535dfee60e65a.png" target = "_blank"><img src="images/7d1f0928fb599d465916e43e731535dfee60e65a.png"></a></a></p>
<h3 id="heading--override-failed">Override failed</h3>

<p>Allows a machine marked as ‘Failed testing’ to be usable.</p>
<h3 id="heading--power-off">Power off</h3>

<p>This action turns off a node&rsquo;s underlying machine.</p>
<h3 id="heading--power-on">Power on</h3>

<p>This action turns on a node&rsquo;s underlying machine.</p>
<h3 id="heading--release">Release</h3>

<p>This action, which includes the &lsquo;Power off&rsquo; action, releases a node back into the pool of available nodes, changing a node&rsquo;s status from &lsquo;Deployed&rsquo; (or &lsquo;Allocated&rsquo;) to &lsquo;Ready&rsquo;.</p>
<p>The user has the opportunity to erase the node&rsquo;s storage (disks) before confirming the action. You can configure a default erasure setting on the &lsquo;Storage&rsquo; tab of the &lsquo;Settings&rsquo; page. See <a href="disk-erasure.html">Disk erasure</a> for details.</p>
<h3 id="heading--rescue-mode">Rescue mode</h3>

<p>This action allows you to boot a node ephemerally (Ubuntu running in memory on the underlying machine). By doing so, you can SSH to the machine for maintenance purposes. This action works for a Deployed or Broken node, as well as for a node that failed to deploy.</p>
<p>Authentication and access to the node&rsquo;s storage work the same way it would if the node were deployed. The fact that ephemeral Ubuntu is running is entirely transparent to the user.</p>
<p>The node status is changed to the &lsquo;Entering rescue mode&rsquo; transitory status and then to &lsquo;Rescue mode&rsquo; when the operation is complete.</p>
<h3 id="heading--set-zone">Set Zone</h3>

<p>This action puts the node in a specific zone.</p>
<h3 id="heading--test-hardware">Test hardware</h3>

<p>This action allows the user to select and run scripts to test a machine&rsquo;s underlying hardware. See <a href="hardware-testing.html">Hardware testing</a> for further details.</p>
<h3 id="heading--unlock">Unlock</h3>

<p>This action releases a machine from a locked state.</p>
<h2 id="heading--machine-statuses">Node statuses</h2>

<p>Node statuses are labels used to describe the general state of a node as known to MAAS. A node will undergo various manipulations during their time spent in MAAS, and its status will change accordingly. Actions applied to a node are the most common cause of a status change (see section above.)  Below is the full list of status values and their meaning, arranged alphabetically.</p>
<p>Some aspects of a node can only be modified when a node has a certain status. Examples:</p>
<ul>
<li>you cannot modify a network interfaces unless the node has a status of either &lsquo;Ready&rsquo; or &lsquo;Broken&rsquo;.</li>
<li>you cannot modify storage unless the node has a status of either &lsquo;Ready&rsquo; or &lsquo;Allocated&rsquo;.</li>
</ul>
<h3 id="heading--allocated">Allocated</h3>

<p>The node is allocated (reserved) to a MAAS user. See node action &lsquo;Acquire&rsquo;.</p>
<h3 id="heading--broken">Broken</h3>

<p>The node is broken. See node action &lsquo;Mark broken&rsquo;.</p>
<h3 id="heading--commissioning">Commissioning</h3>

<p>The node is in the process of commissioning. See node action &lsquo;Commission&rsquo;.</p>
<h3 id="heading--deployed">Deployed</h3>

<p>The node is deployed. See node action &lsquo;Deploy&rsquo;.</p>
<p>The visible status will be the name of the chosen OS (e.g. &lsquo;Ubuntu 16.04 LTS&rsquo;).</p>
<h3 id="heading--deploying">Deploying</h3>

<p>The node is in the process of deploying. See node action &lsquo;Deploy&rsquo;.</p>
<p>The visible status will be Deploying to &lsquo;OS&rsquo;, where &lsquo;OS&rsquo; is the name of the OS being deployed (e.g. &lsquo;Deploying to Ubuntu 16.04 LTS&rsquo;).</p>
<h3 id="heading--entering-rescue-mode">Entering rescue mode</h3>

<p>The node is in the process of entering rescue mode. See node action &lsquo;Rescue mode&rsquo;.</p>
<h3 id="heading--exiting-rescue-mode">Exiting rescue mode</h3>

<p>The node is in the process of exiting rescue mode. See node action &lsquo;Exit rescue mode&rsquo;.</p>
<h3 id="heading--failed-commissioning">Failed Commissioning</h3>

<p>The node failed to commission.</p>
<h3 id="heading--failed-deployment">Failed Deployment</h3>

<p>The node failed to deploy.</p>
<h3 id="heading--locked">Locked</h3>

<p>It&rsquo;s not strictly a status, but a machine showing a &lsquo;padlock&rsquo; symbol adjacent to its name is in a locked state.</p>
<h3 id="heading--new">New</h3>

<p>This status represents the first stage of a node&rsquo;s life in MAAS. Typically, a node with this status has just been added to MAAS.</p>
<h3 id="heading--ready">Ready</h3>

<p>A node bearing this status has been commissioned and is ready for use, including the necessary BMC credentials. MAAS can start or stop this machine, and allocate or (re)deploy it with a fresh operating system.</p>
<h3 id="heading--rescue-mode">Rescue mode</h3>

<p>The node is in rescue mode and is ready to accept SSH connections. See node action &lsquo;Rescue mode&rsquo;.</p>
<h2 id-"heading--package-repositories">Package repositories</h2>

<p>Package repositories managed within MAAS can be of two types:</p>
<ul>
<li>Ubuntu package repositories</li>
<li>Personal Package Archives (PPA)</li>
</ul>
<p>You can configure repositories in the &lsquo;Package repositories&rsquo; tab on the &lsquo;Settings&rsquo; page. Any enabled repository listed on this page will become automatically available to any subsequently deployed nodes.</p>
<p>MAAS further simplifies the addition of third-party repositories by also allowing the administrator to input their respective GPG keys here. This arrangement means that nodes will have instant access to these repositories (i.e. no need to import the keys into APT).</p>
<p>An added repository can be disabled and re-enabled using a toggle switch to the right of it.</p>
<h2 id="heading--ubuntu-package-repositories">Ubuntu package repositories</h2>

<p>An Ubuntu package repository is a repository that makes available Ubuntu packages to computers able to connect to it over the network, whether that network is private or public (e.g. the Internet).</p>
<p>MAAS comes equipped with the official Ubuntu repository <code>archive.ubuntu.com</code> as well as the equivalent for architectures other than i386 and amd64: <code>ports.ubuntu.com</code> as is evident in the default configuration below:</p>
<p><a href="images/77b93794-manage-repositories__2.4_default-repo-config.png" target = "_blank"><img src="images/77b93794-manage-repositories__2.4_default-repo-config.png"></a></a></p>
<p>Adding a third-party repository is elementary. Begin by basing the configuration on a line you would typically place in a system&rsquo;s <code>/etc/apt/sources.list</code> file. For instance, for the Google Chrome repository, the line would look like:</p>
<p><code>deb http://dl.google.com/linux/chrome/deb stable main</code></p>
<p>You will also need the GPG public key that is associated with the private key that signed this particular repository. Typically, the project&rsquo;s website is consulted to obtain this information. For this example, you could download the key like this:</p>
<pre><code class="bash">wget https://dl.google.com/linux/linux_signing_key.pub
</code></pre>

<p>The key now resides in the saved file <code>linux_signing_key.pub</code> for later use.</p>
<p>To add this repository, then, hit the &lsquo;Add repository&rsquo; button and fill in the fields using the gathered information. Note that the &lsquo;Name&rsquo; is an arbitrary label to give the repository.</p>
<p>Before saving, the form should look very similar to this:</p>
<p><a href="images/1aa1c512-manage-repositories__2.4_add-repo.png" target = "_blank"><img src="images/1aa1c512-manage-repositories__2.4_add-repo.png"></a></a></p>
<p>Click &lsquo;Add repository&rsquo; to save the configuration.</p>
<p>A private repository can be built to assist with offline operations, based on the official repository. This repository can also contain custom packages.</p>
<h2 id="heading--personal-package-archives-ppa">Personal Package Archives (PPA)</h2>

<p>A Personal Package Archive (PPA) is a <a href="https://launchpad.net">Launchpad</a>-based method for any individual (or team) to build and distribute packages for Ubuntu.</p>
<p>Adding a PPA is equally straightforward. Using the <a href="https://launchpad.net/~canonical-support/+archive/ubuntu/support-tools"><code>sosreport</code> PPA</a> as an example, first acquire the PPA&rsquo;s address from its page on Launchpad:</p>
<p><code>ppa:canonical-support/support-tools</code></p>
<p>Like before, a public GPG key will be needed. Also get this from the PPA&rsquo;s Launchpad page: &lsquo;Technical details about this PPA&rsquo; &gt; &lsquo;1024R/9360754F&rsquo; &gt; &lsquo;9360754F&rsquo;.</p>
<p>To add this PPA, then, hit the &lsquo;Add repository&rsquo; button and fill in the fields. Before saving, the form should look something like this:</p>
<p><a href="images/a0962e17-manage-repositories__2.4_add-ppa.png" target = "_blank"><img src="images/a0962e17-manage-repositories__2.4_add-ppa.png"></a></a></p>
<p>Click &lsquo;Add repository&rsquo; to save the configuration.</p>
<p>See <a href="https://help.launchpad.net/Packaging/PPA">Launchpad PPAs</a> for more information on PPAs.</p>
<h2 id="heading--numa">NUMA/vNUMA</a>

NUMA stands for "Non-Uniform Memory Access."  In this context, "non-uniform" means that any given CPU core can access its dedicated memory faster than the memory dedicated to other cores.  A NUMA configuration groups core(s) and memory as a dedicated node, which reduces memory access times, so the core won't spend a lot of time stalled in wait states -- that is, waiting for access to data in memory, either because the memory is relatively far away (proximity) or because other cores have access to the same memory (shared memory). In other words, NUMA works better when the core has dedicated memory that is relatively close by.

In this context, "far away" could mean physical distance (more wire or a longer bus distance), more interceding processes (as in virtual machines), or both.  The process of optimising thread and process scheduling so that the core running the code and the required data are close together is sometimes known as "creating affinity." This affinity creates NUMA "nodes," which can be addressed as black boxes from a symmetric multi-processing (SMP) point of view.  Tasks are assigned to nodes to minimise overhead and wait states.

There is more flexibility in creating affinity when using virtual machines, because memory and core are constructs overlaid on existing hardware, rather than hard silicon.  While this seems as if it might make SMP easier, in fact, it creates difficulties because of the nature of virtual machines and the potential number of interceding processes that manage virtual memory.  For optimum performance, VMs should be aligned to a single NUMA node, so that resources are not split across nodes.

In practice, this means that VMs would be "pinned" to specific cores to create stability.  While the user has the choice of how to pin VMs, MAAS provides visual information that helps the user see how VMs are allocated to physical hardware, and make adjustments if that arrangement isn't (or turns out not to be) optimal.

If you want to dig deeper, there is a [more through treatment of NUMA](https://en.wikipedia.org/wiki/Non-uniform_memory_access) on Wikipedia.

<h2 id="heading--sr-iov">SR-IOV</h2>

With traditional ethernet, a packet comes into the NIC and interrupt is fired for the one core assigned to handle NIC interrupts.  That core has to go get the packet, find the destination MAC address or VLAN tag, then go interrupt the destination core -- which has to get the packet and write it to the memory of the VM it's managing. Statistically speaking, that's basically two core interrupts for every incoming packet.

Many smart NICs are able to sort network packets into queues, based on MAC address or VLAN tag of the intended recipient, a technology sometimes known as "VMDq".  In these cases, each queue has its own interrupt, so each core gets interrupted only for its own packets. This arrangement is much faster than having one core assigned to handle all network interrupts.  Even so, the hypervisor still has to copy every packet from the NIC to the VM, physically touching each packet.

With SR-IOV, it's possible to have no core interrupts when packets come in.  SR-IOV creates "virtual functions," with dedicated queues for transmitting and receiving.  Each VM is directly assigned hardware resources via a virtual function driver, which knows how to DMA-copy data directly between the NIC and the memory space of the relevant VM. Essentially, SR-IOV is like a "jumper wire" between the NIC and the VM, bypassing the core.  This prevents interrupting the core when packets arrive for it, and significantly reduces the core workload when sending network packets.

For a deeper dive, try this [SR-IOV presentation](https://www.youtube.com/watch?v=hRHsk8Nycdg) from Intel.

<h2 id="heading--isolcpus">Isolating CPUs</h2>

For certain operations, it's useful to shield a from having to execute general system processes and take interrupts.  These are sometimes referred to as "isolcpus," more correctly described as booting a core with the `isolcpus` boot parameter.  This parameter restricts the shielded core to processes assigned directly to it, avoiding sharing bandwidth with the general scheduler and preventing the core from taking non-specific interrupts.

When used with VMs, users can maximise performance by configuring isolcpus in the kernel, to prevent the general scheduler and other tasks from using bandwidth on your VM core(s).

<h2 id="heading--edge-clouds">Edge clouds</h2>

Edge clouds are designed to minimise latency, so that your cloud computing experience is nearer to real-time.  The use of "edge" doesn't specifically refer to the edges of the cloud, but to the machines that are at the "edge of the problem," or more to the point, "the edge of the cloud that is closest to your application."  Sometimes these are separate clouds in your own data centre, though they can also be parts of a remote cloud that are closer to you in network terms.

There are a number of complex decision lops and optimisation algorithms used by edge clouds, but the primary purpose is low-latency computing where possible.  If the servers closest to you (network-wise) can handle the load, they do; if not, they can call on other servers just a little further away.

Edge clouds can be planned and enhanced by using NUMA and SR-IOV techniques.  NUMA can help you create SMP nodes on VM cores the shortest (network) distance away from your application.  SR-IOV can, in general, reduce network latency even more by eliminating core involvement in network traffic. You can create virtual machines and assign NUMA nodes to minimise network latency, and then ensure that   MAAS gives you NUMA tools to find out whether you're achieving this sort of optimisation, and help you make decisions about how to adjust and improve over time.

<h2 id="Hugepages">Hugepages</h2>

Computer memory is addressed not as raw RAM, but as virtual memory. Assisted by the CPU's memory management unit (MMU), the kernel maps virtual memory to a physical location. Virtual memory is divided into pages, which can be swapped in and out to disk during normal operation (hence the term "swap space").  When programs access memory, the CPU needs to know which physical page has the data, so it relies on the kernel's "page table" to find the right virtual-to-physical address mapping.

Since this page table is big and slow, the CPU has a special buffer -- the Translation Lookaside Buffer (TLB) -- that caches address mapping.  This means after the first access to a page, subsequent accesses are much faster.  Since this buffer is implemented in hardware, for speed, the size is limited to, say, 4096 bytes.

When the core is accessing lots of pages, the speed advantage of the TLB can be lost.  Hugepages allow one TLB entry to point to 2MB, instead of just 4096 bytes.  With 512 TLB entires, typically, you can map 1GB of memory.  Hugepages come with a catch, though: if you have to swap pages, it (obviously) takes longer.

There's no tried and true formula for when to use them, but the key consideration is that you want to use most of a hugepage when you swap.  Rather than using little sections of a hugepage, which would mean losing the performance advantage from constant swapping, you want to maximize the use of each hugepage.  While there's no simple, empirical way to calculate this answer, you can do it by trial-and-error observation.

MAAS provides the dashboards and tools necessary to monitor and adjust your use of hugepages, so that you can find the right balance.

<h2 id="heading--network-tutorial">Brief network tutorial</h2>

The following is a brief network tutorial, provided as a tool to synchronise understanding.  Note that this tutorial covers mostly those terms routinely needed in the course of using MAAS.

<h3 id="heading--dhcp">DHCP</h3>

The Dynamic Host Control Protocol is a network management system in which a server (or group of servers) dynamically assigns IP addresses and other network parameters to a network device.  This network device may or may not have the capability to provide its own IP address, although to take advantage of DHCP, the device must have been configured to seek out a DHCP server and accept an assigned IP address.  Typically, a network administrator defines a range of reserved IP addresses from which the DHCP server can pull when assigning addresses.

DHCP operates using the "DORA" model: Discovery, Offer, Request, and Acknowledge:

1. Potential DHCP clients broadcast a DHCPDISCOVER message on its attached subnet using destination address 255.255.255.255.

2. A connected DHCP server receives the DHCPDISCOVER message and sends a DHCPOFFER message, containing an IP address that the client may use.

3. The client replies with a DHCPREQUEST message, requesting the offered address.

4. The DHCP server responds with a DHCPACK (acknowledgement) which includes various important configuration parameters, such as the lease duration.

Of course, there is [much more to DHCP](https://en.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol), but what's covered here should be sufficient understanding for using MAAS.

<h3 id="heading--client">Client</h3>

In the client/server age, the lines between client and server are blurred and sometimes reversible.  For the purposes of MAAS and general networking principles, we can define a "client" as a node that uses shared resources via a network.  If that same client provides shared resources to other nodes, it could also be considered a server.  

<h3 id="heading--server">Server</h3>

A server is a node that provides shared resources to clients via a network.  If that same server uses shared resources from other nodes, it could also be considered a client, but only in that context.  

<h3 id="heading--network-interface">Network interface</h3>

A network interface, often referred to as a "network interface card" or NIC, is either a separate physical card connected to a node, a set of circuits embedded on a node's motherboard, or a radio transceiver attached to a node in some way.  All network connections require a NIC.  The terms "port" and "adaptor" are also used to refer to a network interface.

<h3 id="heading--mac-address">MAC address</h3>

A MAC or "media access control" address is a unique address or "physical address" associated with a network interface.  They are 48 bits in length, which allows for 280 trillion devices, arranged into six hexadecimal octets, separated by colons or dashes.  Every computer in the world theoretically has a unique MAC address.  You can identify a node's IP address with the command `ipconfig /all`.

<h3 id="heading--network-cable">Network cable</h3>

Network cables are special cables that connect non-wireless-based nodes.  They consist of our pairs of insulated, 24-gauge wire, colour-coded (solid/striped), usually in four colours: blue, green, orange, and brown.  The matching colour pairs are twisted together, each pair at a different turn rate to prevent electromagnetic interference between pairs.
These twists must be maintained all the way up to the (RJ45) connector.

Even with insulation, careful twisting, and connector-termination, natural losses in the cable cause the network signals to become too weak to maintain reliable data rates after a certain length.  In the case of Cat 5e cable, the maximum cable length is 100 meters to maintain 1Gb per second.  For Cat 6, the max length to maintain 10Gb per second is 55 meters.  These limits are overcome with [repeaters](concepts-and-terms.html#heading--repeater), which amplify the signal and relay it to the next repeater or NIC.

<h3 id="heading--repeater">Repeater</h3>

Technically, a repeater is a network signal amplifier with two RJ45 connectors which adds one maximum length (for the cable type) to the network connection or "run."  In practice, repeaters usually come in the form of [hubs](concepts-and-terms.html#heading--hub) or [switches](concepts-and-terms.html#heading--switch), which can usually perform other functions as well.

<h3 id="heading--packet">Packet</h3>

A packet is a unit of network traffic.  It may or may not represent a complete message.

<h3 id="heading--hub">Hub</h3>

Hubs essentially started as repeaters.  While they may be able to connect more than two computers together (i.e., multiple RJ45 ports), they provide no improvement over simple bus networks, since every connected NIC must examine every packet.  They are rarely used anymore.

<h3 id="heading--switch">Switch</h3>

A switch is a "smart" device that connects cables from nodes to make networks.  Like a hub, a switch amplifies signals, that is, it acts as a repeater.  Switches learn by induction which cables receive which IP addresses.  Over time a switch will direct each packet only to devices which indicate that they will accept the addresses associated with those packets.

<h3 id="heading--network-topology">Network topology</h3>

Topology describes how nodes are connected to a network, specifically referring to the shapes made by the cables and the paths that packets can take.  There are probably as many topologies are there are shapes, but here are a few of the most common:

* Bus topology: the most basic network topology, a group of computers connected to a single, long cable.  In this configuration, every computer sees every packet.  A [hub](concepts-and-terms.html#heading--hub) network, for instance, is still a bus topology, because every machine sees every packet.

* Star or switch topology: a group of computers connected to a [switch](concepts-and-terms.html#heading--switch).  As the switch learns where packets are supposed to go, the star quickly evolves so that only packets are only seen by computers that are intended to receive the packet.

* Backbone topology: a hybrid network configuration in which several stars are connected to a bus.

* Daisy-chain topology: stars connected to stars, or more accurately, switches connected to switches.

* Mesh topology: nodes with multiple interfaces and multiple connections.  Useful where wide-area networks ([WAN](concepts-and-terms.html#heading--wan)) where there would otherwise be lots of intermediaries.  Not popular or particularly cost effective for [LAN](concepts-and-terms.html#heading--lan) networks.

<h3 id="heading--patch-panel">Patch panel</h3>

A patch panel is simply a 24- to 48-port panel of connectors that can link together three- to ten-foot cables.  A patch panel allows jumpers from network runs to devices in racks, without putting strain and "cable creep" on long runs.

<h3 id="heading--lan">LAN</h3>

Besides topology, networks can also be classified by their size, range, or "reach."  One such classification is the Local Area Network (LAN), which connects computers in close proximity (about 300 feet).

<h3 id="heading--WAN">WAN</h3>

A WAN (wide area network) is a network which connects LANs across large geographic distances, e.g., thousands of miles.

<h3 id="heading--MAN">MAN</h3>

A metro area network or MAN connects LANs over a smaller area, like a city or urban footprint.  Basically, if it isn't really a WAN, but you can't connect it with cables, it's usually considered a MAN.

<h3 id="heading--network-infrastructure">Network infrastructure</h3>

Network infrastructure is a catch-all term covering the physical components of a network, include cables, patch panels, switches, routers, hubs, and other associated network gear.

<h3 id="heading--router">Router</h3>

A router is a device that transfers packets from one network to another.  Unlike switches, which only ensure that pre-addressed packets get to the correct recipient machines, routers actually modify or encapsulate packets to ensure that they can travel on other networks to reach a remote destination.

<!-- IMAGES -->
<!-- LINKS -->
    </div>
  </body>
</html>