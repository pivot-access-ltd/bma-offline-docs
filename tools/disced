#!/usr/bin/python3

import argparse
import os
import filecmp
import markdown2
import re
import shutil
import subprocess
import sys
import yaml

from collections import OrderedDict
from git import Repo
from pathlib import Path
from discourse_api import DiscourseAPI  # Import the DiscourseAPI class


def are_files_different(file1_path, file2_path):
    return not filecmp.cmp(file1_path, file2_path)


def ask_yes_no_question(prompt):
    while True:
        response = input(prompt).lower()
        if response == "yes":
            return True
        elif response == "no":
            return False
        else:
            print("Please enter yes or no.")


def commit_and_push(git_directory, commit_message):
    orig_dir = os.getcwd()
    os.chdir(git_directory)
    subprocess.run(["git", "add", "."])
    subprocess.run(["git", "commit", "-m", commit_message])
    subprocess.run(["git", "push"])
    os.chdir(orig_dir)


def copy_file(source_path, destination_path):
    shutil.copy2(source_path, destination_path)


def execute_shell_command(command_string):
    try:
        result = subprocess.run(
            command_string, shell=True, capture_output=True, text=True
        )
        return result.returncode, result.stdout, result.stderr
    except Exception as e:
        return 1, "", str(e)


def extract_sections(file_content, version, view):
    # first, extract all the versions from the file
    continuous_buffer = ""
    current_section = ""
    inside_tab = False
    inside_version = False

    for line in file_content.split("\n"):
        if "[tabs]" in line:
            pass
        elif "[/tabs]" in line:
            pass
        elif '[tab version="' in line:
            inside_tab = True
            if version in line:
                if "view" in line:
                    if view in line:
                        inside_version = True
                else:
                    inside_version = True
        elif "[/tab]" in line:
            inside_tab = False
            if inside_version:
                continuous_buffer += current_section
                current_section = ""
                inside_version = False
        elif inside_tab:
            if inside_version:
                current_section += line + "\n"
            else:
                pass
        else:
            current_section += line + "\n"
    if current_section:
        continuous_buffer += current_section

    return continuous_buffer


# def extract_tab_versions(markdown_content):
#     # Regular expression pattern to match the tab versions label
#     version_pattern = r'\[tab version="([^"]+)"\]'

#     # Find all matches using regex
#     matches = re.findall(version_pattern, markdown_content)

#     # Split compound versions and add each version to the list
#     tab_versions = []
#     for match in matches:
#         versions = match.split(",")
#         tab_versions.extend(versions)

#     # Remove duplicates by converting the list to a set and then back to a list
#     unique_versions = list(set(tab_versions))

#     # Sort the unique versions list in alphabetical order (descending)
#     sorted_versions = sorted(unique_versions, reverse=True)

#     return sorted_versions


def extract_tab_versions(markdown_content):
    # Regular expression pattern to match the tab versions label
    version_pattern = r'\[tab version="v([\d.]+)(?: (?:Snap|Packages))?"\]'

    # Find all matches using regex
    matches = re.findall(version_pattern, markdown_content)

    # Remove duplicates by converting the list to a set & then back to a list
    unique_versions = list(set(matches))

    # Sort the unique versions list in descending order
    sorted_versions = sorted(unique_versions, reverse=True)

    return sorted_versions


def find_file(directory, topic_number):
    for filename in os.listdir(directory):
        if str(topic_number) in filename:
            return filename
    return None


def generate_html_from_markdown_with_title(markdown_content, title, css_filename):
    # Convert Markdown to HTML
    html_content = markdown2.markdown(markdown_content)

    # Embed a link to the CSS stylesheet
    css_link = f'<link rel="stylesheet" type="text/css" href="{css_filename}" />'

    # Replace the specific link format with desired links
    html_content = replace_custom_links(html_content)

    # Construct the complete HTML content with embedded styles and title
    complete_html_content = f"""<!DOCTYPE html>
<html>
  <head>
    <title>{title}</title>
    {css_link}
    <style>
      #selector a:link{{color:black;}}
      #selector a:visited{{color:black;}}
      #selector a:active{{color:black;}}
      #selector a:hover{{color:blue;}}
      /* ... (other CSS rules) ... */
    </style>
  </head>
  <body>
    <div id="selector" style="top:0; position:fixed; float:right; background-color:#d9d9d9; width:100%;border-bottom:1px solid black;">
      <!-- ... (content for the selector div) ... -->
    </div>
    <div id="sidebar" style="float:left; width:25%;margin-top:40px; margin-left:20px">
      <!-- ... (content for the sidebar div) ... -->
    </div>
    <div class="container" style="float:right; width:65%; margin-top:40px; margin-right:30px">
      <h1>{title}</h1>  <!-- Set the extracted title as H1 -->
      {html_content}
    </div>
  </body>
</html>"""

    return complete_html_content


def load_config(config_file):
    with config_file.open() as f:
        return yaml.safe_load(f)


def parse_sections(file_content):
    sections = {}
    current_version = None
    current_section = ""

    for line in file_content.split("\n"):
        version_match = re.match(r'\[tab version="(.+)"', line)
        if version_match:
            current_version = version_match.group(1)
            current_section = ""
        elif line == "[/tab]":
            if current_version:
                if current_version not in sections:
                    sections[current_version] = []
                sections[current_version].append(current_section.strip())
                current_section = ""
        else:
            current_section += line + "\n"

    return sections


def print_config(config):
    for key, value in config.items():
        print(f"Key: {key}, Value: {value}")


def make_html(
    markdown_content,
    version,
    packaging_format,
    view,
    topic_title,
    css_filename,
    output_dir,
    filename,
):
    if "Packages" in packaging_format:
        package_format = "deb"
    else:
        package_format = "snap"

    extracted_sections = extract_sections(
        markdown_content, "v" + version + " " + packaging_format, view
    )
    html_content = generate_html_from_markdown_with_title(
        extracted_sections, topic_title, css_filename
    )

    html_dir = os.path.join(
        output_dir, f"production-html-{package_format}/{view.lower()}"
    )
    os.makedirs(html_dir, exist_ok=True)

    filename_without_extension = os.path.splitext(filename)[0]

    # Remove the last hyphen and the digits after it, if present
    filename_without_extension = "-".join(filename_without_extension.split("-")[:-1])

    html_filename = os.path.join(html_dir, f"{filename_without_extension}.html")

    with open(html_filename, "w") as file:
        file.write(html_content)
        print(f"Created HTML version: {version} {view}")


def pull_file_from_repo(file_url, destination_path):
    response = requests.get(file_url)

    if response.status_code == 200:
        with open(destination_path, "wb") as f:
            f.write(response.content)
        print("File pulled from repository and written to the specified path.")
    else:
        print("Failed to pull the file from the repository.")


def replace_custom_links(html_content):
    # Regular expression pattern to match specific link format
    link_pattern = r"/t/([^/]+)/(\d+)"

    # Replace links in the HTML content using regex substitution
    modified_content = re.sub(link_pattern, r"\1-\2.html", html_content)

    return modified_content


def main():
    # set presets
    cfgfile = Path.home() / ".config/maas-doc/maas-doc.yaml"
    config = load_config(cfgfile)
    staging = config.get("staging_repo")
    master = config.get("master_repo")
    staging_topic = config.get("staging_topic")
    sdocs = staging + "/src/"
    mdocs = master + "/src/"
    wip = staging + "/maas-discourse/"

    # parse args
    parser = argparse.ArgumentParser(description="Discourse topic number")
    parser.add_argument(
        "-t",
        "--topic_number",
        type=int,
        required=True,
        help="The Discourse topic number to be edited",
    )
    parser.add_argument(
        "-m",
        "--commit_message",
        type=ascii,
        help="A commit message which overrides all hardcoded commit messages",
    )
    parser.add_argument(
        "-a",
        "--append_galley",
        action="store_true",
        default=False,
        help="Append new galley to existing galley post",
    )
    parser.add_argument("--debug", action="store_true", help="Print debug information")
    args = parser.parse_args()

    # validate topic number, otherwise halt
    md_file = find_file(sdocs, args.topic_number)
    if not md_file:
        print(f"Topic {args.topic_number} not found; aborting")
        sys.exit()
    staging_file = sdocs + md_file

    # commit staging branch to launchpad, warts and all
    commit_and_push(staging, "updating staging dir with latest drafts")

    # pull topic from discourse to staging/wip
    base_url = config.get("base_url")
    api = DiscourseAPI(base_url, config)
    topic_json = api.get_topic(args.topic_number)
    post_id = topic_json["post_stream"]["posts"][0]["id"]
    post_json = api.get_post(post_id)
    topic_title = api.get_title(topic_json)
    disc_content = post_json["raw"]
    discourse_file = wip + md_file
    with open(discourse_file, "w") as f:
        f.write(disc_content)

    # locate staging and master versions of this file
    staging_file = sdocs + md_file
    master_file = mdocs + md_file

    # diff master and discourse versions
    result = are_files_different(master_file, discourse_file)

    # if they don't match, commit discourse changes to master
    if result:
        copy_file(discourse_file, master_file)
        commit_string = "commit discourse changes for topic "
        commit_string += str(args.topic_number)
        commit_and_push(master, commit_string)

    # diff staging and discourse files
    result = are_files_different(staging_file, discourse_file)

    # set editor command based on whether they match or not
    emacs = "emacs --no-splash --maximized -q -l ~/.emacs2 "
    if result:
        diff_file = wip + md_file + ".diff"
        diffcmd = "diff " + staging_file + " " + discourse_file + " > " + diff_file
        execute_shell_command(diffcmd)

        edcmd = emacs
        edcmd += "--eval " + '"(custom-open-files-layout ' + "\\" + '"'
        edcmd += diff_file + "\\" + '"' + " \\" + '"'
        edcmd += staging_file + "\\" + '"' + " \\" + '"'
        edcmd += discourse_file + "\\" + '")"'
    else:
        edcmd = emacs + staging_file

    # run the editor
    return_code, stdout, stderr = execute_shell_command(edcmd)
    if return_code != 0:
        print(stderr)
        print(edcmd + " failed: aborting")
        sys.exit()

    # stage the results to the staging discourse topic
    with open(staging_file, "r") as file:
        markdown_content = file.read()
    api = DiscourseAPI(base_url, config)
    # you can either add it to the end of the galley, or just replace
    # the first post in the galley; this allows comparing edits
    if args.append_galley:
        api.post_to_topic(staging_topic, markdown_content)
    else:
        api.update_topic_content(staging_topic, markdown_content)

    if ask_yes_no_question(
        "Do you want to publish the staging file to Discourse? (yes/no): "
    ):
        # Publish content of the staging_file to args.topic_number
        api.update_topic_content(args.topic_number, markdown_content)

        # Copy the staging file over the master file
        copy_file(staging_file, master_file)

        # Commit the master repo with a user-entered message
        commit_message = input("Enter a commit message for the master repo: ")
        commit_and_push(master, commit_message)
    else:
        print("Discourse not updated.")

    if ask_yes_no_question("Do you want to build an HTML version? (yes/no): "):
        # extract tab and view versions for section extraction
        tab_versions = extract_tab_versions(markdown_content)

        # Present available tab versions
        print("Available tab versions:")
        num_versions = len(tab_versions)
        half_num_versions = (num_versions + 1) // 2  # Round up division

        for i in range(half_num_versions):
            left_idx = i
            right_idx = i + half_num_versions
            left_version = tab_versions[left_idx]
            right_version = tab_versions[right_idx] if right_idx < num_versions else ""
            print(f"{left_idx + 1}. {left_version:<30}", end="")
            if right_version:
                print(f"{right_idx + 1}. {right_version}")
            else:
                print()

        print(f"{num_versions + 1}. None")

        # Get user's choice as a number
        while True:
            try:
                choice_number = int(
                    input(
                        "Choose a number for the desired tab version (or '0' for None): "
                    )
                )
                if 0 <= choice_number <= len(tab_versions) + 1:
                    if choice_number == 0:
                        print("No HTML version will be generated.")
                        break
                    chosen_version = tab_versions[choice_number - 1]
                    break
                else:
                    print("Invalid choice. Please enter a valid number.")
            except ValueError:
                print("Invalid input. Please enter a number.")

        if choice_number != 0:
            # generate HTML versions based on chosen tab version
            css_filename = os.path.join(master, "html-support/css/stylesheet.css")
            make_html(
                markdown_content,
                chosen_version,
                "Snap",
                "UI",
                topic_title,
                css_filename,
                master,
                md_file,
            )
            make_html(
                markdown_content,
                chosen_version,
                "Packages",
                "UI",
                topic_title,
                css_filename,
                master,
                md_file,
            )
            make_html(
                markdown_content,
                chosen_version,
                "Snap",
                "CLI",
                topic_title,
                css_filename,
                master,
                md_file,
            )
            make_html(
                markdown_content,
                chosen_version,
                "Packages",
                "CLI",
                topic_title,
                css_filename,
                master,
                md_file,
            )
        else:
            print("No HTML version built.")


if __name__ == "__main__":
    main()
